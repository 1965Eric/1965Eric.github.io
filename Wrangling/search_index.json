[
["learning-objectives.html", "Data Science Wrangling 1 Learning Objectives 1.1 Course Overview 1.2 Introduction to Wrangling", " Data Science Wrangling 1 Learning Objectives How to import data into R from different file formats How to scrape data from the web How to tidy data using the tidyverse to better facilitate analysis How to process strings with regular expressions (regex) How to wrangle data using dplyr How to work with dates and times as file formats How to mine text 1.1 Course Overview 1.1.1 Section 1: Data Import You will learn how to import data from different sources. 1.1.2 Section 2: Tidy Data You will learn the first pieces of converting data into a tidy format. 1.1.3 Section 3: String Processing You will learn how to process strings using regular expressions (regex). 1.1.4 Section 4: Dates, Times, and Text Mining You will learn how to work with dates and times as file formats and how to mine text. 1.2 Introduction to Wrangling The textbook for this section is available here. Key points The first step in data analysis is importing, tidying and cleaning the data. This is the process of data wrangling. In this course, we cover several common steps of the data wrangling process: tidying data, string processing, html parsing, working with dates and times, and text mining. "],
["section-1-overview.html", "2 Section 1 Overview 2.1 Importing Spreadsheets 2.2 Paths and the Working Directory 2.3 The readr and readxl Packages 2.4 Importing Data Using R-base Functions 2.5 Downloading Files from the Internet 2.6 Assessment Part 1 - Data Import 2.7 Assessment Part 2 - Data Import", " 2 Section 1 Overview In the Data Import section, you will learn how import data into R. After completing this section, you will be able to: Import data from spreadsheets. Identify and set your working directory and specify the path to a file. Use the readr and readxl packages to import spreadsheets. Use R-base functions to import spreadsheets. Download files from the internet using R. The textbook for this section is available here. 2.1 Importing Spreadsheets The textbook for this section is available here. Key points Many datasets are stored in spreadsheets. A spreadsheet is essentially a file version of a data frame with rows and columns. Spreadsheets have rows separated by returns and columns separated by a delimiter. The most common delimiters are comma, semicolon, white space and tab. Many spreadsheets are raw text files and can be read with any basic text editor. However, some formats are proprietary and cannot be read with a text editor, such as Microsoft Excel files (.xls). Most import functions assume that the first row of a spreadsheet file is a header with column names. To know if the file has a header, it helps to look at the file with a text editor before trying to import it. 2.2 Paths and the Working Directory The textbook for this section is available here. Key points The working directory is where R looks for files and saves files by default. See your working directory with getwd(). Change your working directory with setwd(). We suggest you create a directory for each project and keep your raw data inside that directory. Use the file.path() function to generate a full path from a relative path and a file name. Use file.path() instead of paste() because file.path() is aware of your operating system and will use the correct slashes to navigate your machine. The file.copy() function copies a file to a new path. Code # see working directory getwd() # change your working directory setwd() # set path to the location for raw data files in the dslabs package and list files path &lt;- system.file(&quot;extdata&quot;, package=&quot;dslabs&quot;) list.files(path) ## [1] &quot;2010_bigfive_regents.xls&quot; &quot;carbon_emissions.csv&quot; &quot;fertility-two-countries-example.csv&quot; ## [4] &quot;HRlist2.txt&quot; &quot;life-expectancy-and-fertility-two-countries-example.csv&quot; &quot;murders.csv&quot; ## [7] &quot;olive.csv&quot; &quot;RD-Mortality-Report_2015-18-180531.pdf&quot; &quot;ssa-death-probability.csv&quot; # generate a full path to a file filename &lt;- &quot;murders.csv&quot; fullpath &lt;- file.path(path, filename) fullpath ## [1] &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library/dslabs/extdata/murders.csv&quot; # copy file from dslabs package to your working directory file.copy(fullpath, getwd()) ## [1] FALSE # check if the file exists file.exists(filename) ## [1] TRUE 2.3 The readr and readxl Packages The textbook for this section is available here. Key points readr is the tidyverse library that includes functions for reading data stored in text file spreadsheets into R. Functions in the package include read_csv(), read_tsv(), read_delim() and more. These differ by the delimiter they use to split columns. The readxl package provides functions to read Microsoft Excel formatted files. The excel_sheets() function gives the names of the sheets in the Excel file. These names are passed to the sheet argument for the readxl functions read_excel(), read_xls() and read_xlsx(). The read_lines() function shows the first few lines of a file in R. Code if(!require(dslabs)) install.packages(&quot;dslabs&quot;) ## Loading required package: dslabs if(!require(tidyverse)) install.packages(&quot;tidyverse&quot;) ## Loading required package: tidyverse ## ── Attaching packages ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.3 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() if(!require(readxl)) install.packages(&quot;readxl&quot;) ## Loading required package: readxl library(dslabs) library(tidyverse) # includes readr library(readxl) # inspect the first 3 lines read_lines(&quot;murders.csv&quot;, n_max = 3) ## [1] &quot;state,abb,region,population,total&quot; &quot;Alabama,AL,South,4779736,135&quot; &quot;Alaska,AK,West,710231,19&quot; # read file in CSV format dat &lt;- read_csv(filename) ## Parsed with column specification: ## cols( ## state = col_character(), ## abb = col_character(), ## region = col_character(), ## population = col_double(), ## total = col_double() ## ) #read using full path dat &lt;- read_csv(fullpath) ## Parsed with column specification: ## cols( ## state = col_character(), ## abb = col_character(), ## region = col_character(), ## population = col_double(), ## total = col_double() ## ) head(dat) ## # A tibble: 6 x 5 ## state abb region population total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alabama AL South 4779736 135 ## 2 Alaska AK West 710231 19 ## 3 Arizona AZ West 6392017 232 ## 4 Arkansas AR South 2915918 93 ## 5 California CA West 37253956 1257 ## 6 Colorado CO West 5029196 65 #Ex： path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) files &lt;- list.files(path) files ## [1] &quot;2010_bigfive_regents.xls&quot; &quot;carbon_emissions.csv&quot; &quot;fertility-two-countries-example.csv&quot; ## [4] &quot;HRlist2.txt&quot; &quot;life-expectancy-and-fertility-two-countries-example.csv&quot; &quot;murders.csv&quot; ## [7] &quot;olive.csv&quot; &quot;RD-Mortality-Report_2015-18-180531.pdf&quot; &quot;ssa-death-probability.csv&quot; filename &lt;- &quot;murders.csv&quot; filename1 &lt;- &quot;life-expectancy-and-fertility-two-countries-example.csv&quot; filename2 &lt;- &quot;fertility-two-countries-example.csv&quot; dat=read.csv(file.path(path, filename)) dat1=read.csv(file.path(path, filename1)) dat2=read.csv(file.path(path, filename2)) 2.4 Importing Data Using R-base Functions The textbook for this section is available here. Key point R-base import functions (read.csv(), read.table(), read.delim()) generate data frames rather than tibbles and character variables are converted to factors. This can be avoided by setting the argument stringsAsFactors=FALSE. Code # read.csv converts strings to factors dat2 &lt;- read.csv(filename) class(dat2$abb) ## [1] &quot;character&quot; class(dat2$region) ## [1] &quot;character&quot; 2.5 Downloading Files from the Internet The textbook for this section is available here. Key points The read_csv() function and other import functions can read a URL directly. If you want to have a local copy of the file, you can use download.file(). tempdir() creates a directory with a name that is very unlikely not to be unique. tempfile() creates a character string that is likely to be a unique filename. Code url &lt;- &quot;https://raw.githubusercontent.com/rafalab/dslabs/master/inst/extdata/murders.csv&quot; dat &lt;- read_csv(url) ## Parsed with column specification: ## cols( ## state = col_character(), ## abb = col_character(), ## region = col_character(), ## population = col_double(), ## total = col_double() ## ) download.file(url, &quot;murders.csv&quot;) tempfile() ## [1] &quot;/var/folders/6m/nz2p76pn679b692c99t644bm0000gn/T//RtmpnqMzj7/file3447474aaa04&quot; tmp_filename &lt;- tempfile() download.file(url, tmp_filename) dat &lt;- read_csv(tmp_filename) ## Parsed with column specification: ## cols( ## state = col_character(), ## abb = col_character(), ## region = col_character(), ## population = col_double(), ## total = col_double() ## ) file.remove(tmp_filename) ## [1] TRUE 2.6 Assessment Part 1 - Data Import Which of the following is NOT part of the data wrangling process? A. Importing data into R B. Formatting dates/times C. Checking correlations between your variables D. Tidying data Which files could be opened in a basic text editor? Select ALL that apply. A. data.txt B. data.csv C. data.xlsx D. data.tsv You want to analyze a file containing race finish times for a recent marathon. You open the file in a basic text editor and see lines that look like the following: initials,state,age,time vib,MA,61,6:01 adc,TX,45,5:45 kme,CT,50,4:19 What type of file is this? A. A comma-delimited file without a header B. A tab-delimited file with a header C. A white space-delimited file without a header D. A comma-delimited file with a header Assume the following is the full path to the directory that a student wants to use as their working directory in R: “/Users/student/Documents/projects/” Which of the following lines of code CANNOT set the working directory to the desired “projects” directory? A. setwd(\"~/Documents/projects/\") B. setwd(\"/Users/student/Documents/projects/\") C. setwd(/Users/student/Documents/projects/) D. dir &lt;- \"/Users/student/Documents/projects\" setwd(dir) We want to copy the “murders.csv” file from the dslabs package into an existing folder “data”, which is located in our HarvardX-Wrangling projects folder. We first enter the code below into our RStudio console. &gt; getwd() [1] &quot;C:/Users/UNIVERSITY/Documents/Analyses/HarvardX-Wrangling&quot; &gt; filename &lt;- &quot;murders.csv&quot; &gt; path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) Which of the following commands would NOT successfully copy “murders.csv” into the folder “data”? A. file.copy(file.path(path, \"murders.csv\"), getwd()) B. file.copy(file.path(path, filename), getwd()) C. file.copy(file.path(path, \"murders.csv\"), file.path(getwd(), \"data\")) D. file.location &lt;- file.path(system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;), &quot;murders.csv&quot;) file.destination &lt;- file.path(getwd(),&quot;data&quot;) file.copy(file.location, file.destination) You are not sure whether the murders.csv file has a header row. How could you check this? Select ALL that apply. A. Open the file in a basic text editor. B. In the RStudio “Files” pane, click on your file, then select “View File”. C. Use the command read_lines (remembering to specify the number of rows with the n_max argument). What is one difference between read_excel and read_xlsx? A. read_excel() also reads meta-data from the excel file, such as sheet names, while read_xlsx() only reads the first sheet in a file. B. read_excel() reads both .xls and .xlsx files by detecting the file format from its extension, while read_xlsx() only reads .xlsx files. C. read_excel() is part of the readr package, while read_xlsx() is part of the readxl package and has more options. D. read_xlsx() has been replaced by read_excel() in a recent readxl package update. You have a file called “times.txt” that contains race finish times for a marathon. The first four lines of the file look like this: initials,state,age,time vib,MA,61,6:01 adc,TX,45,5:45 kme,CT,50,4:19 Which line of code will NOT produce a tibble with column names “initials”, “state”, “age”, and “time”? A. race_times &lt;- read_csv(\"times.txt\") B. race_times &lt;- read.csv(\"times.txt\") C. race_times &lt;- read_csv(\"times.txt\", col_names = TRUE) D. race_times &lt;- read_delim(\"times.txt\", delim = “,”) You also have access to marathon finish times in the form of an Excel document named “times.xlsx”. In the Excel document, different sheets contain race information for different years. The first sheet is named “2015”, the second is named “2016”, and the third is named “2017”. Which line of code will NOT import the data contained in the “2016” tab of this Excel sheet? A. times_2016 &lt;- read_excel(\"times.xlsx\", sheet = 2) B. times_2016 &lt;- read_xlsx(\"times.xlsx\", sheet = “2”) C. times_2016 &lt;- read_excel(\"times.xlsx\", sheet = \"2016\") D. times_2016 &lt;- read_xlsx(\"times.xlsx\", sheet = 2) You have a comma-separated values file that contains the initials, home states, ages, and race finish times for marathon runners. The runners’ initials contain three characters for the runners’ first, middle, and last names (for example, “KME”). You read in the file using the following code. race_times &lt;- read.csv(“times.csv”) What is the data type of the initials in the object race_times? A. integers B. characters C. factors D. logical Which of the following is NOT a real difference between the readr import functions and the base R import functions? A. The import functions in the readr package all start as read_, while the import functions for base R all start with read. B. Base R import functions automatically convert character columns to factors. C. The base R import functions can read .csv files, but cannot files with other delimiters, such as .tsv files, or fixed-width files. D. Base R functions import data as a data frame, while readr functions import data as a tibble. You read in a file containing runner information and marathon finish times using the following code. race_times &lt;- read.csv(“times.csv”, stringsAsFactors = F) What is the class of the object race_times? A. data frame B. tibble C. matrix D. vector Select the answer choice that summarizes all of the actions that the following lines of code can perform. Please note that the url below is an example and does not lead to data. url &lt;- &quot;https://raw.githubusercontent.com/MyUserName/MyProject/master/MyData.csv &quot; dat &lt;- read_csv(url) download.file(url, &quot;MyData.csv&quot;) A. Create a tibble in R called dat that contains the information contained in the csv file stored on Github and save that tibble to the working directory. B. Create a matrix in R called dat that contains the information contained in the csv file stored on Github. Download the csv file to the working directory and name the downloaded file “MyData.csv”. C. Create a tibble in R called dat that contains the information contained in the csv file stored on Github. Download the csv file to the working directory and randomly assign it a temporary name that is very likely to be unique. D. Create a tibble in R called dat that contains the information contained in the csv file stored on Github. Download the csv file to the working directory and name the downloaded file “MyData.csv”. 2.7 Assessment Part 2 - Data Import Inspect the file at the following URL: https://raw.githubusercontent.com/rasbt/python-machine-learning-book/master/code/datasets/wdbc/wdbc.data Which readr function should be used to import this file? A. read_table() B. read_csv() C. read_csv2() D. read_tsv() E. None of the above Check the documentation for the readr function you chose in the previous question to learn about its arguments. Determine which arguments you need to the file from the previous question: url &lt;- &quot;https://raw.githubusercontent.com/rasbt/python-machine-learning-book/master/code/datasets/wdbc/wdbc.data&quot; Does this file have a header row? Does the readr function you chose need any additional arguments to import the data correctly? A. Yes, there is a header. No arguments are needed. B. Yes, there is a header. The header=TRUE argument is necessary. C. Yes, there is a header. The col_names=TRUE argument is necessary. D. No, there is no header. No arguments are needed. E. No, there is no header. The header=FALSE argument is necessary. F. No, there is no header. The col_names=FALSE argument is necessary. Inspect the imported data from the previous question. How many rows are in the dataset? url &lt;- &quot;https://raw.githubusercontent.com/rasbt/python-machine-learning-book/master/code/datasets/wdbc/wdbc.data&quot; df &lt;- read_csv(url, col_names = FALSE) ## Parsed with column specification: ## cols( ## .default = col_double(), ## X2 = col_character() ## ) ## See spec(...) for full column specifications. nrow(df) ## [1] 569 How many columns are in the dataset? ncol(df) ## [1] 32 "],
["section-2-overview.html", "3 Section 2 Overview 3.1 Tidy Data 3.2 Reshaping Data 3.3 Separate and Unite 3.4 Assessment Part 1 - Reshaping Data 3.5 Assessment Part 2 - Reshaping Data 3.6 Combining Tables 3.7 Binding 3.8 Set Operators 3.9 Assessment - Combining Tables 3.10 Web Scraping 3.11 CSS Selectors 3.12 Assessment - Web Scraping", " 3 Section 2 Overview In the Tidy Data section, you will learn how to convert data from a raw to a tidy format. This section is divided into three parts: Reshaping Data, Combining Tables, and Web Scraping. After completing the Tidy Data section, you will be able to: Reshape data using functions from the tidyr package, including gather(), spread(), separate(), and unite(). Combine information from different tables using join functions from the dplyr package. Combine information from different tables using binding functions from the dplyr package. Use set operators to combine data frames. Gather data from a website through web scraping and use of CSS selectors. 3.1 Tidy Data The textbook for this section is available here. Key points In tidy data, each row represents an observation and each column represents a different variable. In wide data, each row includes several observations and one of the variables is stored in the header. Code data(gapminder) # create and inspect a tidy data frame tidy_data &lt;- gapminder %&gt;% filter(country %in% c(&quot;South Korea&quot;, &quot;Germany&quot;)) %&gt;% select(country, year, fertility) head(tidy_data) ## country year fertility ## 1 Germany 1960 2.41 ## 2 South Korea 1960 6.16 ## 3 Germany 1961 2.44 ## 4 South Korea 1961 5.99 ## 5 Germany 1962 2.47 ## 6 South Korea 1962 5.79 # plotting tidy data is simple tidy_data %&gt;% ggplot(aes(year, fertility, color = country)) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point). # import and inspect example of original Gapminder data in wide format path &lt;- system.file(&quot;extdata&quot;, package=&quot;dslabs&quot;) filename &lt;- file.path(path, &quot;fertility-two-countries-example.csv&quot;) wide_data &lt;- read_csv(filename) ## Parsed with column specification: ## cols( ## .default = col_double(), ## country = col_character() ## ) ## See spec(...) for full column specifications. select(wide_data, country, `1960`:`1967`) ## # A tibble: 2 x 9 ## country `1960` `1961` `1962` `1963` `1964` `1965` `1966` `1967` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2.41 2.44 2.47 2.49 2.49 2.48 2.44 2.37 ## 2 South Korea 6.16 5.99 5.79 5.57 5.36 5.16 4.99 4.85 3.2 Reshaping Data The textbook for this section is available here, here and here. Key points The tidyr package includes several functions that are useful for tidying data. The gather() function converts wide data into tidy data. The spread() function converts tidy data to wide data. Code # original wide data path &lt;- system.file(&quot;extdata&quot;, package=&quot;dslabs&quot;) filename &lt;- file.path(path, &quot;fertility-two-countries-example.csv&quot;) wide_data &lt;- read_csv(filename) ## Parsed with column specification: ## cols( ## .default = col_double(), ## country = col_character() ## ) ## See spec(...) for full column specifications. # tidy data from dslabs tidy_data &lt;- gapminder %&gt;% filter(country %in% c(&quot;South Korea&quot;, &quot;Germany&quot;)) %&gt;% select(country, year, fertility) # gather wide data to make new tidy data new_tidy_data &lt;- wide_data %&gt;% gather(year, fertility, `1960`:`2015`) head(new_tidy_data) ## # A tibble: 6 x 3 ## country year fertility ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960 2.41 ## 2 South Korea 1960 6.16 ## 3 Germany 1961 2.44 ## 4 South Korea 1961 5.99 ## 5 Germany 1962 2.47 ## 6 South Korea 1962 5.79 # gather all columns except country new_tidy_data &lt;- wide_data %&gt;% gather(year, fertility, -country) # gather treats column names as characters by default class(tidy_data$year) ## [1] &quot;integer&quot; class(new_tidy_data$year) ## [1] &quot;character&quot; # convert gathered column names to numeric new_tidy_data &lt;- wide_data %&gt;% gather(year, fertility, -country, convert = TRUE) class(new_tidy_data$year) ## [1] &quot;integer&quot; # ggplot works on new tidy data new_tidy_data %&gt;% ggplot(aes(year, fertility, color = country)) + geom_point() # spread tidy data to generate wide data new_wide_data &lt;- new_tidy_data %&gt;% spread(year, fertility) select(new_wide_data, country, `1960`:`1967`) ## # A tibble: 2 x 9 ## country `1960` `1961` `1962` `1963` `1964` `1965` `1966` `1967` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2.41 2.44 2.47 2.49 2.49 2.48 2.44 2.37 ## 2 South Korea 6.16 5.99 5.79 5.57 5.36 5.16 4.99 4.85 3.3 Separate and Unite The textbook for this section is available here and here. Key points The separate() function splits one column into two or more columns at a specified character that separates the variables. When there is an extra separation in some of the entries, use fill=\"right\" to pad missing values with NAs, or use extra=\"merge\" to keep extra elements together. The unite() function combines two columns and adds a separating character. Code # import data path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) filename &lt;- file.path(path, &quot;life-expectancy-and-fertility-two-countries-example.csv&quot;) raw_dat &lt;- read_csv(filename) ## Parsed with column specification: ## cols( ## .default = col_double(), ## country = col_character() ## ) ## See spec(...) for full column specifications. select(raw_dat, 1:5) ## # A tibble: 2 x 5 ## country `1960_fertility` `1960_life_expectancy` `1961_fertility` `1961_life_expectancy` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2.41 69.3 2.44 69.8 ## 2 South Korea 6.16 53.0 5.99 53.8 # gather all columns except country dat &lt;- raw_dat %&gt;% gather(key, value, -country) head(dat) ## # A tibble: 6 x 3 ## country key value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960_fertility 2.41 ## 2 South Korea 1960_fertility 6.16 ## 3 Germany 1960_life_expectancy 69.3 ## 4 South Korea 1960_life_expectancy 53.0 ## 5 Germany 1961_fertility 2.44 ## 6 South Korea 1961_fertility 5.99 dat$key[1:5] ## [1] &quot;1960_fertility&quot; &quot;1960_fertility&quot; &quot;1960_life_expectancy&quot; &quot;1960_life_expectancy&quot; &quot;1961_fertility&quot; # separate on underscores dat %&gt;% separate(key, c(&quot;year&quot;, &quot;variable_name&quot;), &quot;_&quot;) ## Warning: Expected 2 pieces. Additional pieces discarded in 112 rows [3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 31, 32, 35, 36, 39, 40, ...]. ## # A tibble: 224 x 4 ## country year variable_name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960 fertility 2.41 ## 2 South Korea 1960 fertility 6.16 ## 3 Germany 1960 life 69.3 ## 4 South Korea 1960 life 53.0 ## 5 Germany 1961 fertility 2.44 ## 6 South Korea 1961 fertility 5.99 ## 7 Germany 1961 life 69.8 ## 8 South Korea 1961 life 53.8 ## 9 Germany 1962 fertility 2.47 ## 10 South Korea 1962 fertility 5.79 ## # … with 214 more rows dat %&gt;% separate(key, c(&quot;year&quot;, &quot;variable_name&quot;)) ## Warning: Expected 2 pieces. Additional pieces discarded in 112 rows [3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 31, 32, 35, 36, 39, 40, ...]. ## # A tibble: 224 x 4 ## country year variable_name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960 fertility 2.41 ## 2 South Korea 1960 fertility 6.16 ## 3 Germany 1960 life 69.3 ## 4 South Korea 1960 life 53.0 ## 5 Germany 1961 fertility 2.44 ## 6 South Korea 1961 fertility 5.99 ## 7 Germany 1961 life 69.8 ## 8 South Korea 1961 life 53.8 ## 9 Germany 1962 fertility 2.47 ## 10 South Korea 1962 fertility 5.79 ## # … with 214 more rows # split on all underscores, pad empty cells with NA dat %&gt;% separate(key, c(&quot;year&quot;, &quot;first_variable_name&quot;, &quot;second_variable_name&quot;), fill = &quot;right&quot;) ## # A tibble: 224 x 5 ## country year first_variable_name second_variable_name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960 fertility &lt;NA&gt; 2.41 ## 2 South Korea 1960 fertility &lt;NA&gt; 6.16 ## 3 Germany 1960 life expectancy 69.3 ## 4 South Korea 1960 life expectancy 53.0 ## 5 Germany 1961 fertility &lt;NA&gt; 2.44 ## 6 South Korea 1961 fertility &lt;NA&gt; 5.99 ## 7 Germany 1961 life expectancy 69.8 ## 8 South Korea 1961 life expectancy 53.8 ## 9 Germany 1962 fertility &lt;NA&gt; 2.47 ## 10 South Korea 1962 fertility &lt;NA&gt; 5.79 ## # … with 214 more rows # split on first underscore but keep life_expectancy merged dat %&gt;% separate(key, c(&quot;year&quot;, &quot;variable_name&quot;), sep = &quot;_&quot;, extra = &quot;merge&quot;) ## # A tibble: 224 x 4 ## country year variable_name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960 fertility 2.41 ## 2 South Korea 1960 fertility 6.16 ## 3 Germany 1960 life_expectancy 69.3 ## 4 South Korea 1960 life_expectancy 53.0 ## 5 Germany 1961 fertility 2.44 ## 6 South Korea 1961 fertility 5.99 ## 7 Germany 1961 life_expectancy 69.8 ## 8 South Korea 1961 life_expectancy 53.8 ## 9 Germany 1962 fertility 2.47 ## 10 South Korea 1962 fertility 5.79 ## # … with 214 more rows # separate then spread dat %&gt;% separate(key, c(&quot;year&quot;, &quot;variable_name&quot;), sep = &quot;_&quot;, extra = &quot;merge&quot;) %&gt;% spread(variable_name, value) ## # A tibble: 112 x 4 ## country year fertility life_expectancy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 1960 2.41 69.3 ## 2 Germany 1961 2.44 69.8 ## 3 Germany 1962 2.47 70.0 ## 4 Germany 1963 2.49 70.1 ## 5 Germany 1964 2.49 70.7 ## 6 Germany 1965 2.48 70.6 ## 7 Germany 1966 2.44 70.8 ## 8 Germany 1967 2.37 71.0 ## 9 Germany 1968 2.28 70.6 ## 10 Germany 1969 2.17 70.5 ## # … with 102 more rows # separate then unite dat %&gt;% separate(key, c(&quot;year&quot;, &quot;first_variable_name&quot;, &quot;second_variable_name&quot;), fill = &quot;right&quot;) %&gt;% unite(variable_name, first_variable_name, second_variable_name, sep=&quot;_&quot;) ## # A tibble: 224 x 4 ## country year variable_name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 1960 fertility_NA 2.41 ## 2 South Korea 1960 fertility_NA 6.16 ## 3 Germany 1960 life_expectancy 69.3 ## 4 South Korea 1960 life_expectancy 53.0 ## 5 Germany 1961 fertility_NA 2.44 ## 6 South Korea 1961 fertility_NA 5.99 ## 7 Germany 1961 life_expectancy 69.8 ## 8 South Korea 1961 life_expectancy 53.8 ## 9 Germany 1962 fertility_NA 2.47 ## 10 South Korea 1962 fertility_NA 5.79 ## # … with 214 more rows # full code for tidying data dat %&gt;% separate(key, c(&quot;year&quot;, &quot;first_variable_name&quot;, &quot;second_variable_name&quot;), fill = &quot;right&quot;) %&gt;% unite(variable_name, first_variable_name, second_variable_name, sep=&quot;_&quot;) %&gt;% spread(variable_name, value) %&gt;% rename(fertility = fertility_NA) ## # A tibble: 112 x 4 ## country year fertility life_expectancy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 1960 2.41 69.3 ## 2 Germany 1961 2.44 69.8 ## 3 Germany 1962 2.47 70.0 ## 4 Germany 1963 2.49 70.1 ## 5 Germany 1964 2.49 70.7 ## 6 Germany 1965 2.48 70.6 ## 7 Germany 1966 2.44 70.8 ## 8 Germany 1967 2.37 71.0 ## 9 Germany 1968 2.28 70.6 ## 10 Germany 1969 2.17 70.5 ## # … with 102 more rows 3.4 Assessment Part 1 - Reshaping Data A collaborator sends you a file containing data for three years of average race finish times. age_group,2015,2016,2017 20,3:46,3:22,3:50 30,3:50,3:43,4:43 40,4:39,3:49,4:51 50,4:48,4:59,5:01 Are these data considered “tidy” in R? Why or why not? A. Yes. These data are considered “tidy” because each row contains unique observations. B. Yes. These data are considered “tidy” because there are no missing data in the data frame. C. No. These data are not considered “tidy” because the variable “year” is stored in the header. D. No. These data are not considered “tidy” because there are not an equal number of columns and rows. Below are four versions of the same dataset. Which one is in a tidy format? A. state abb region population total Alabama AL South 4779736 135 Alaska AK West 710231 19 Arizona AZ West 6392017 232 Arkansas AR South 2915918 93 California CA West 37253956 1257 Colorado CO West 5029196 65 B. state abb region var people Alabama AL South population 4779736 Alabama AL South total 135 Alaska AK West population 710231 Alaska AK West total 19 Arizona AZ West population 6392017 Arizona AZ West total 232 C. state abb Northeast South North Central West Alabama AL NA 4779736 NA NA Alaska AK NA NA NA 710231 Arizona AZ NA NA NA 6392017 Arkansas AR NA 2915918 NA NA California CA NA NA NA 37253956 Colorado CO NA NA NA 5029196 D. state abb region rate Alabama AL South 2.82e-05 Alaska AK West 2.68e-05 Arizona AZ West 3.63e-05 Arkansas AR South 3.19e-05 California CA West 3.37e-05 Colorado CO West 1.29e-05 Your file called “times.csv” has age groups and average race finish times for three years of marathons. age_group,2015,2016,2017 20,3:46,3:22,3:50 30,3:50,3:43,4:43 40,4:39,3:49,4:51 50,4:48,4:59,5:01 You read in the data file using the following command. d &lt;- read_csv(&quot;files/times.csv&quot;) ## Parsed with column specification: ## cols( ## age_group = col_double(), ## `2015` = col_time(format = &quot;&quot;), ## `2016` = col_time(format = &quot;&quot;), ## `2017` = col_time(format = &quot;&quot;) ## ) Which commands will help you “tidy” the data? tidy_data &lt;- d %&gt;% gather(year, time, `2015`:`2017`) tidy_data ## # A tibble: 12 x 3 ## age_group year time ## &lt;dbl&gt; &lt;chr&gt; &lt;time&gt; ## 1 20 2015 03:46 ## 2 30 2015 03:50 ## 3 40 2015 04:39 ## 4 50 2015 04:48 ## 5 20 2016 03:22 ## 6 30 2016 03:43 ## 7 40 2016 03:49 ## 8 50 2016 04:59 ## 9 20 2017 03:50 ## 10 30 2017 04:43 ## 11 40 2017 04:51 ## 12 50 2017 05:01 A. tidy_data &lt;- d %&gt;% gather(year, time, `2015`:`2017`) B. tidy_data &lt;- d %&gt;% spread(year, time, `2015`:`2017`) C. tidy_data &lt;- d %&gt;% gather(age_group, year, time, `2015`:`2017`) D. tidy_data &lt;- d %&gt;% gather(time, `2015`:`2017`) You have a dataset on U.S. contagious diseases, but it is in the following wide format: &gt; head(dat_wide) state year population Hepatitis A Mumps Polio Rubella Alabama 1990 4040587 86 19 76 1 Alabama 1991 4066003 39 14 65 0 Alabama 1992 4097169 35 12 24 0 Alabama 1993 4133242 40 22 67 0 Alabama 1994 4173361 72 12 39 0 Alabama 1995 4216645 75 2 38 0 Which of the following would transform this into a tidy dataset, with each row representing an observation of the incidence of each specific disease (as shown below)? &gt; head(dat_tidy) state year population disease count Alabama 1990 4040587 Hepatitis A 86 Alabama 1991 4066003 Hepatitis A 39 Alabama 1992 4097169 Hepatitis A 35 Alabama 1993 4133242 Hepatitis A 40 Alabama 1994 4173361 Hepatitis A 72 Alabama 1995 4216645 Hepatitis A 75 A. dat_tidy &lt;- dat_wide %&gt;% gather (key = count, value = disease, `Hepatitis A`, `Rubella`) B. dat_tidy &lt;- dat_wide %&gt;% gather(key = count, value = disease, -state, -year, -population) C. dat_tidy &lt;- dat_wide %&gt;% gather(key = disease, value = count, -state) D. dat_tidy &lt;- dat_wide %&gt;% gather(key = disease, value = count, “Hepatitis A”: “Rubella”) You have successfully formatted marathon finish times into a tidy object called tidy_data. The first few lines are shown below. age_group year time 20 2015 03:46 30 2015 03:50 40 2015 04:39 50 2015 04:48 20 2016 03:22 Select the code that converts these data back to the wide format, where each year has a separate column. tidy_data %&gt;% spread(year, time) ## # A tibble: 4 x 4 ## age_group `2015` `2016` `2017` ## &lt;dbl&gt; &lt;time&gt; &lt;time&gt; &lt;time&gt; ## 1 20 03:46 03:22 03:50 ## 2 30 03:50 03:43 04:43 ## 3 40 04:39 03:49 04:51 ## 4 50 04:48 04:59 05:01 A. tidy_data %&gt;% spread(time, year) B. tidy_data %&gt;% spread(year, time) C. tidy_data %&gt;% spread(year, age_group) D. tidy_data %&gt;% spread(time, year, `2015`:`2017`) You have the following dataset: &gt; head(dat) state abb region var people Alabama AL South population 4779736 Alabama AL South total 135 Alaska AK West population 710231 Alaska AK West total 19 Arizona AZ West population 6392017 Arizona AZ West total 232 You would like to transform it into a dataset where population and total are each their own column (shown below). Which code would best accomplish this? state abb region population total Alabama AL South 4779736 135 Alaska AK West 710231 19 Arizona AZ West 6392017 232 Arkansas AR South 2915918 93 California CA West 37253956 1257 Colorado CO West 5029196 65 A. dat_tidy &lt;- dat %&gt;% spread(key = var, value = people) B. dat_tidy &lt;- dat %&gt;% spread(key = state:region, value = people) C. dat_tidy &lt;- dat %&gt;% spread(key = people, value = var) D. dat_tidy &lt;- dat %&gt;% spread(key = region, value = people) A collaborator sends you a file containing data for two years of average race finish times, “times2.csv”:. age_group,2015_time,2015_participants,2016_time,2016_participants 20,3:46,54,3:22,62 30,3:50,60,3:43,58 40,4:39,29,3:49,33 50,4:48,10,4:59,14 You read in the data file d &lt;- read_csv(&quot;files/times2.csv&quot;) ## Parsed with column specification: ## cols( ## age_group = col_double(), ## `2015_time` = col_time(format = &quot;&quot;), ## `2015_participants` = col_double(), ## `2016_time` = col_time(format = &quot;&quot;), ## `2016_participants` = col_double() ## ) Which of the answers below best tidys the data? tidy_data &lt;- d %&gt;% gather(key = &quot;key&quot;, value = &quot;value&quot;, -age_group) %&gt;% separate(col = key, into = c(&quot;year&quot;, &quot;variable_name&quot;), sep = &quot;_&quot;) %&gt;% spread(key = variable_name, value = value) ## Warning: attributes are not identical across measure variables; ## they will be dropped tidy_data ## # A tibble: 8 x 4 ## age_group year participants time ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 2015 54 13560 ## 2 20 2016 62 12120 ## 3 30 2015 60 13800 ## 4 30 2016 58 13380 ## 5 40 2015 29 16740 ## 6 40 2016 33 13740 ## 7 50 2015 10 17280 ## 8 50 2016 14 17940 A. tidy_data &lt;- d %&gt;% gather(key = “key”, value = “value”, -age_group) %&gt;% separate(col = key, into = c(“year”, “variable_name”), sep = “.”) %&gt;% spread(key = variable_name, value = value) B. tidy_data &lt;- d %&gt;% gather(key = “key”, value = “value”, -age_group) %&gt;% separate(col = key, into = c(“year”, “variable_name”), sep = “_”) %&gt;% spread(key = variable_name, value = value) C. tidy_data &lt;- d %&gt;% gather(key = “key”, value = “value”) %&gt;% separate(col = key, into = c(“year”, “variable_name”), sep = “_”) %&gt;% spread(key = variable_name, value = value) D. tidy_data &lt;- d %&gt;% gather(key = “key”, value = “value”, -age_group) %&gt;% separate(col = key, into = “year”, sep = “_”) %&gt;% spread(key = year, value = value) You are in the process of tidying some data on heights, hand length, and wingspan for basketball players in the draft. Currently, you have the following: &gt; head(stats) key value allen_height 75 allen_hand_length 8.25 allen_wingspan 79.25 bamba_height 83.25 bamba_hand_length 9.75 bamba_wingspan 94 Select all of the correct commands below that would turn this data into a “tidy” format. A. tidy_data &lt;- stats %&gt;% separate(col = key, into = c(&quot;player&quot;, &quot;variable_name&quot;), sep = &quot;_&quot;, extra = &quot;merge&quot;) %&gt;% spread(key = variable_name, value = value) B. tidy_data &lt;- stats %&gt;% separate(col = key, into = c(&quot;player&quot;, &quot;variable_name1&quot;, &quot;variable_name2&quot;), sep = &quot;_&quot;, fill = &quot;right&quot;) %&gt;% unite(col = variable_name, variable_name1, variable_name2, sep = &quot;_&quot;) %&gt;% spread(key = variable_name, value = value) C. tidy_data &lt;- stats %&gt;% separate(col = key, into = c(&quot;player&quot;, &quot;variable_name&quot;), sep = &quot;_&quot;) %&gt;% spread(key = variable_name, value = value) 3.5 Assessment Part 2 - Reshaping Data Examine the built-in dataset co2. This dataset comes with base R, not dslabs - just type co2 to access the dataset. co2 ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1959 315.42 316.31 316.50 317.56 318.13 318.00 316.39 314.65 313.68 313.18 314.66 315.43 ## 1960 316.27 316.81 317.42 318.87 319.87 319.43 318.01 315.74 314.00 313.68 314.84 316.03 ## 1961 316.73 317.54 318.38 319.31 320.42 319.61 318.42 316.63 314.83 315.16 315.94 316.85 ## 1962 317.78 318.40 319.53 320.42 320.85 320.45 319.45 317.25 316.11 315.27 316.53 317.53 ## 1963 318.58 318.92 319.70 321.22 322.08 321.31 319.58 317.61 316.05 315.83 316.91 318.20 ## 1964 319.41 320.07 320.74 321.40 322.06 321.73 320.27 318.54 316.54 316.71 317.53 318.55 ## 1965 319.27 320.28 320.73 321.97 322.00 321.71 321.05 318.71 317.66 317.14 318.70 319.25 ## 1966 320.46 321.43 322.23 323.54 323.91 323.59 322.24 320.20 318.48 317.94 319.63 320.87 ## 1967 322.17 322.34 322.88 324.25 324.83 323.93 322.38 320.76 319.10 319.24 320.56 321.80 ## 1968 322.40 322.99 323.73 324.86 325.40 325.20 323.98 321.95 320.18 320.09 321.16 322.74 ## 1969 323.83 324.26 325.47 326.50 327.21 326.54 325.72 323.50 322.22 321.62 322.69 323.95 ## 1970 324.89 325.82 326.77 327.97 327.91 327.50 326.18 324.53 322.93 322.90 323.85 324.96 ## 1971 326.01 326.51 327.01 327.62 328.76 328.40 327.20 325.27 323.20 323.40 324.63 325.85 ## 1972 326.60 327.47 327.58 329.56 329.90 328.92 327.88 326.16 324.68 325.04 326.34 327.39 ## 1973 328.37 329.40 330.14 331.33 332.31 331.90 330.70 329.15 327.35 327.02 327.99 328.48 ## 1974 329.18 330.55 331.32 332.48 332.92 332.08 331.01 329.23 327.27 327.21 328.29 329.41 ## 1975 330.23 331.25 331.87 333.14 333.80 333.43 331.73 329.90 328.40 328.17 329.32 330.59 ## 1976 331.58 332.39 333.33 334.41 334.71 334.17 332.89 330.77 329.14 328.78 330.14 331.52 ## 1977 332.75 333.24 334.53 335.90 336.57 336.10 334.76 332.59 331.42 330.98 332.24 333.68 ## 1978 334.80 335.22 336.47 337.59 337.84 337.72 336.37 334.51 332.60 332.38 333.75 334.78 ## 1979 336.05 336.59 337.79 338.71 339.30 339.12 337.56 335.92 333.75 333.70 335.12 336.56 ## 1980 337.84 338.19 339.91 340.60 341.29 341.00 339.39 337.43 335.72 335.84 336.93 338.04 ## 1981 339.06 340.30 341.21 342.33 342.74 342.08 340.32 338.26 336.52 336.68 338.19 339.44 ## 1982 340.57 341.44 342.53 343.39 343.96 343.18 341.88 339.65 337.81 337.69 339.09 340.32 ## 1983 341.20 342.35 342.93 344.77 345.58 345.14 343.81 342.21 339.69 339.82 340.98 342.82 ## 1984 343.52 344.33 345.11 346.88 347.25 346.62 345.22 343.11 340.90 341.18 342.80 344.04 ## 1985 344.79 345.82 347.25 348.17 348.74 348.07 346.38 344.51 342.92 342.62 344.06 345.38 ## 1986 346.11 346.78 347.68 349.37 350.03 349.37 347.76 345.73 344.68 343.99 345.48 346.72 ## 1987 347.84 348.29 349.23 350.80 351.66 351.07 349.33 347.92 346.27 346.18 347.64 348.78 ## 1988 350.25 351.54 352.05 353.41 354.04 353.62 352.22 350.27 348.55 348.72 349.91 351.18 ## 1989 352.60 352.92 353.53 355.26 355.52 354.97 353.75 351.52 349.64 349.83 351.14 352.37 ## 1990 353.50 354.55 355.23 356.04 357.00 356.07 354.67 352.76 350.82 351.04 352.69 354.07 ## 1991 354.59 355.63 357.03 358.48 359.22 358.12 356.06 353.92 352.05 352.11 353.64 354.89 ## 1992 355.88 356.63 357.72 359.07 359.58 359.17 356.94 354.92 352.94 353.23 354.09 355.33 ## 1993 356.63 357.10 358.32 359.41 360.23 359.55 357.53 355.48 353.67 353.95 355.30 356.78 ## 1994 358.34 358.89 359.95 361.25 361.67 360.94 359.55 357.49 355.84 356.00 357.59 359.05 ## 1995 359.98 361.03 361.66 363.48 363.82 363.30 361.94 359.50 358.11 357.80 359.61 360.74 ## 1996 362.09 363.29 364.06 364.76 365.45 365.01 363.70 361.54 359.51 359.65 360.80 362.38 ## 1997 363.23 364.06 364.61 366.40 366.84 365.68 364.52 362.57 360.24 360.83 362.49 364.34 Is co2 tidy? Why or why not? A. co2 is tidy data: it has one year for each row. B. co2 is tidy data: each column is a different month. C. co2 is not tidy: there are multiple observations per column. D. co2 is not tidy: to be tidy we would have to wrangle it to have three columns (year, month and value), and then each co2 observation would have a row. Run the following command to define the co2_wide object: co2_wide &lt;- data.frame(matrix(co2, ncol = 12, byrow = TRUE)) %&gt;% setNames(1:12) %&gt;% mutate(year = as.character(1959:1997)) Use the gather() function to make this dataset tidy. Call the column with the CO2 measurements co2 and call the month column month. Name the resulting object co2_tidy. Which code would return the correct tidy format? co2_tidy &lt;- gather(co2_wide,month,co2,-year) A. co2_tidy &lt;- gather(co2_wide,month,co2,year) B. co2_tidy &lt;- gather(co2_wide,co2,month,-year) C. co2_tidy &lt;- gather(co2_wide,co2,month,year) D. co2_tidy &lt;- gather(co2_wide,month,co2,-year) Use co2_tidy to plot CO2 versus month with a different curve for each year: co2_tidy %&gt;% ggplot(aes(as.numeric(month), co2, color = year)) + geom_line() What can be concluded from this plot? A. CO2 concentrations increased monotonically (never decreased) from 1959 to 1997. B. CO2 concentrations are highest around May and the yearly average increased from 1959 to 1997. C. CO2 concentrations are highest around October and the yearly average increased from 1959 to 1997. D. Yearly average CO2 concentrations have remained constant over time. E. CO2 concentrations do not have a seasonal trend. Load the admissions dataset from dslabs, which contains college admission information for men and women across six majors, and remove the applicants percentage column: data(admissions) dat &lt;- admissions %&gt;% select(-applicants) Your goal is to get the data in the shape that has one row for each major, like this: major men women A 62 82 B 63 68 C 37 34 D 33 35 E 28 24 F 6 7 Which command could help you to wrangle the data into the desired format? dat_tidy &lt;- spread(dat, gender, admitted) A. dat_tidy &lt;- spread(dat, major, admitted) B. dat_tidy &lt;- spread(dat, gender, major) C. dat_tidy &lt;- spread(dat, gender, admitted) D. dat_tidy &lt;- spread(dat, admitted, gender) Now use the admissions dataset to create the object tmp, which has columns major, gender, key and value: tmp &lt;- gather(admissions, key, value, admitted:applicants) tmp ## major gender key value ## 1 A men admitted 62 ## 2 B men admitted 63 ## 3 C men admitted 37 ## 4 D men admitted 33 ## 5 E men admitted 28 ## 6 F men admitted 6 ## 7 A women admitted 82 ## 8 B women admitted 68 ## 9 C women admitted 34 ## 10 D women admitted 35 ## 11 E women admitted 24 ## 12 F women admitted 7 ## 13 A men applicants 825 ## 14 B men applicants 560 ## 15 C men applicants 325 ## 16 D men applicants 417 ## 17 E men applicants 191 ## 18 F men applicants 373 ## 19 A women applicants 108 ## 20 B women applicants 25 ## 21 C women applicants 593 ## 22 D women applicants 375 ## 23 E women applicants 393 ## 24 F women applicants 341 Combine the key and gender and create a new column called column_name to get a variable with the following values: admitted_men, admitted_women, applicants_menand applicants_women. Save the new data as tmp2. Which command could help you to wrangle the data into the desired format? tmp2 &lt;- unite(tmp, column_name, c(key, gender)) A. tmp2 &lt;- spread(tmp, column_name, key, gender) B. tmp2 &lt;- gather(tmp, column_name, c(gender,key)) C. tmp2 &lt;- unite(tmp, column_name, c(gender, key)) D. tmp2 &lt;- spread(tmp, column_name, c(key,gender)) E. tmp2 &lt;- unite(tmp, column_name, c(key, gender)) Which function can reshape tmp2 to a table with six rows and five columns named major, admitted_men, admitted_women, applicants_men and applicants_women? spread(tmp2, column_name, value) ## major admitted_men admitted_women applicants_men applicants_women ## 1 A 62 82 825 108 ## 2 B 63 68 560 25 ## 3 C 37 34 325 593 ## 4 D 33 35 417 375 ## 5 E 28 24 191 393 ## 6 F 6 7 373 341 A. gather() B. spread() C. separate() D. unite() 3.6 Combining Tables The textbook for this section is available here. Key points The join functions in the dplyr package combine two tables such that matching rows are together. left_join() only keeps rows that have information in the first table. right_join() only keeps rows that have information in the second table. inner_join() only keeps rows that have information in both tables. full_join() keeps all rows from both tables. semi_join() keeps the part of first table for which we have information in the second. anti_join() keeps the elements of the first table for which there is no information in the second. Code if(!require(ggrepel)) install.packages(&quot;ggrepel&quot;) ## Loading required package: ggrepel # import US murders data library(ggrepel) ds_theme_set() data(murders) head(murders) ## state abb region population total ## 1 Alabama AL South 4779736 135 ## 2 Alaska AK West 710231 19 ## 3 Arizona AZ West 6392017 232 ## 4 Arkansas AR South 2915918 93 ## 5 California CA West 37253956 1257 ## 6 Colorado CO West 5029196 65 # import US election results data data(polls_us_election_2016) head(results_us_election_2016) ## state electoral_votes clinton trump others ## 1 California 55 61.7 31.6 6.7 ## 2 Texas 38 43.2 52.2 4.5 ## 3 Florida 29 47.8 49.0 3.2 ## 4 New York 29 59.0 36.5 4.5 ## 5 Illinois 20 55.8 38.8 5.4 ## 6 Pennsylvania 20 47.9 48.6 3.6 identical(results_us_election_2016$state, murders$state) ## [1] FALSE # join the murders table and US election results table tab &lt;- left_join(murders, results_us_election_2016, by = &quot;state&quot;) head(tab) ## state abb region population total electoral_votes clinton trump others ## 1 Alabama AL South 4779736 135 9 34.4 62.1 3.6 ## 2 Alaska AK West 710231 19 3 36.6 51.3 12.2 ## 3 Arizona AZ West 6392017 232 11 45.1 48.7 6.2 ## 4 Arkansas AR South 2915918 93 6 33.7 60.6 5.8 ## 5 California CA West 37253956 1257 55 61.7 31.6 6.7 ## 6 Colorado CO West 5029196 65 9 48.2 43.3 8.6 # plot electoral votes versus population tab %&gt;% ggplot(aes(population/10^6, electoral_votes, label = abb)) + geom_point() + geom_text_repel() + scale_x_continuous(trans = &quot;log2&quot;) + scale_y_continuous(trans = &quot;log2&quot;) + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; # make two smaller tables to demonstrate joins tab1 &lt;- slice(murders, 1:6) %&gt;% select(state, population) tab1 ## state population ## 1 Alabama 4779736 ## 2 Alaska 710231 ## 3 Arizona 6392017 ## 4 Arkansas 2915918 ## 5 California 37253956 ## 6 Colorado 5029196 tab2 &lt;- slice(results_us_election_2016, c(1:3, 5, 7:8)) %&gt;% select(state, electoral_votes) tab2 ## state electoral_votes ## 1 California 55 ## 2 Texas 38 ## 3 Florida 29 ## 4 Illinois 20 ## 5 Ohio 18 ## 6 Georgia 16 # experiment with different joins left_join(tab1, tab2) ## Joining, by = &quot;state&quot; ## state population electoral_votes ## 1 Alabama 4779736 NA ## 2 Alaska 710231 NA ## 3 Arizona 6392017 NA ## 4 Arkansas 2915918 NA ## 5 California 37253956 55 ## 6 Colorado 5029196 NA tab1 %&gt;% left_join(tab2) ## Joining, by = &quot;state&quot; ## state population electoral_votes ## 1 Alabama 4779736 NA ## 2 Alaska 710231 NA ## 3 Arizona 6392017 NA ## 4 Arkansas 2915918 NA ## 5 California 37253956 55 ## 6 Colorado 5029196 NA tab1 %&gt;% right_join(tab2) ## Joining, by = &quot;state&quot; ## state population electoral_votes ## 1 California 37253956 55 ## 2 Texas NA 38 ## 3 Florida NA 29 ## 4 Illinois NA 20 ## 5 Ohio NA 18 ## 6 Georgia NA 16 inner_join(tab1, tab2) ## Joining, by = &quot;state&quot; ## state population electoral_votes ## 1 California 37253956 55 semi_join(tab1, tab2) ## Joining, by = &quot;state&quot; ## state population ## 1 California 37253956 anti_join(tab1, tab2) ## Joining, by = &quot;state&quot; ## state population ## 1 Alabama 4779736 ## 2 Alaska 710231 ## 3 Arizona 6392017 ## 4 Arkansas 2915918 ## 5 Colorado 5029196 3.7 Binding The textbook for this section is available here. Key points Unlike the join functions, the binding functions do not try to match by a variable, but rather just combine datasets. bind_cols() binds two objects by making them columns in a tibble. The R-base function cbind() binds columns but makes a data frame or matrix instead. The bind_rows() function is similar but binds rows instead of columns. The R-base function rbind() binds rows but makes a data frame or matrix instead. Code bind_cols(a = 1:3, b = 4:6) ## # A tibble: 3 x 2 ## a b ## &lt;int&gt; &lt;int&gt; ## 1 1 4 ## 2 2 5 ## 3 3 6 tab1 &lt;- tab[, 1:3] tab2 &lt;- tab[, 4:6] tab3 &lt;- tab[, 7:9] new_tab &lt;- bind_cols(tab1, tab2, tab3) head(new_tab) ## state abb region population total electoral_votes clinton trump others ## 1 Alabama AL South 4779736 135 9 34.4 62.1 3.6 ## 2 Alaska AK West 710231 19 3 36.6 51.3 12.2 ## 3 Arizona AZ West 6392017 232 11 45.1 48.7 6.2 ## 4 Arkansas AR South 2915918 93 6 33.7 60.6 5.8 ## 5 California CA West 37253956 1257 55 61.7 31.6 6.7 ## 6 Colorado CO West 5029196 65 9 48.2 43.3 8.6 tab1 &lt;- tab[1:2,] tab2 &lt;- tab[3:4,] bind_rows(tab1, tab2) ## state abb region population total electoral_votes clinton trump others ## 1 Alabama AL South 4779736 135 9 34.4 62.1 3.6 ## 2 Alaska AK West 710231 19 3 36.6 51.3 12.2 ## 3 Arizona AZ West 6392017 232 11 45.1 48.7 6.2 ## 4 Arkansas AR South 2915918 93 6 33.7 60.6 5.8 3.8 Set Operators The textbook for this section is available here. Key points By default, the set operators in R-base work on vectors. If tidyverse/dplyr are loaded, they also work on data frames. You can take intersections of vectors using intersect(). This returns the elements common to both sets. You can take the union of vectors using union(). This returns the elements that are in either set. The set difference between a first and second argument can be obtained with setdiff(). Note that this function is not symmetric. The function set_equal() tells us if two sets are the same, regardless of the order of elements. Code # intersect vectors or data frames intersect(1:10, 6:15) ## [1] 6 7 8 9 10 intersect(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), c(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)) ## [1] &quot;b&quot; &quot;c&quot; tab1 &lt;- tab[1:5,] tab2 &lt;- tab[3:7,] intersect(tab1, tab2) ## state abb region population total electoral_votes clinton trump others ## 1 Arizona AZ West 6392017 232 11 45.1 48.7 6.2 ## 2 Arkansas AR South 2915918 93 6 33.7 60.6 5.8 ## 3 California CA West 37253956 1257 55 61.7 31.6 6.7 # perform a union of vectors or data frames union(1:10, 6:15) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 union(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), c(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; tab1 &lt;- tab[1:5,] tab2 &lt;- tab[3:7,] union(tab1, tab2) ## state abb region population total electoral_votes clinton trump others ## 1 Alabama AL South 4779736 135 9 34.4 62.1 3.6 ## 2 Alaska AK West 710231 19 3 36.6 51.3 12.2 ## 3 Arizona AZ West 6392017 232 11 45.1 48.7 6.2 ## 4 Arkansas AR South 2915918 93 6 33.7 60.6 5.8 ## 5 California CA West 37253956 1257 55 61.7 31.6 6.7 ## 6 Colorado CO West 5029196 65 9 48.2 43.3 8.6 ## 7 Connecticut CT Northeast 3574097 97 7 54.6 40.9 4.5 # set difference of vectors or data frames setdiff(1:10, 6:15) ## [1] 1 2 3 4 5 setdiff(6:15, 1:10) ## [1] 11 12 13 14 15 tab1 &lt;- tab[1:5,] tab2 &lt;- tab[3:7,] setdiff(tab1, tab2) ## state abb region population total electoral_votes clinton trump others ## 1 Alabama AL South 4779736 135 9 34.4 62.1 3.6 ## 2 Alaska AK West 710231 19 3 36.6 51.3 12.2 # setequal determines whether sets have the same elements, regardless of order setequal(1:5, 1:6) ## [1] FALSE setequal(1:5, 5:1) ## [1] TRUE setequal(tab1, tab2) ## [1] FALSE 3.9 Assessment - Combining Tables You have created a tab1 and tab2 of state population and election data: &gt; tab1 state population Alabama 4779736 Alaska 710231 Arizona 6392017 Delaware 897934 District of Columbia 601723 &gt; tab2 state electoral_votes Alabama 9 Alaska 3 Arizona 11 California 55 Colorado 9 Connecticut 7 &gt; dim(tab1) [1] 5 2 &gt; dim(tab2) [1] 6 2 What are the dimensions of the table dat, created by the following command? dat &lt;- left_join(tab1, tab2, by = “state”) A. 3 rows by 3 columns B. 5 rows by 2 columns C. 5 rows by 3 columns D. 6 rows by 3 columns We are still using the tab1 and ```tab2 tables shown in question 1. What join command would create a new table “dat” with three rows and two columns? A. dat &lt;- right_join(tab1, tab2, by = “state”) B. dat &lt;- full_join(tab1, tab2, by = “state”) C. dat &lt;- inner_join(tab1, tab2, by = “state”) D. dat &lt;- semi_join(tab1, tab2, by = “state”) Which of the following are real differences between the join and bind functions? A. Binding functions combine by position, while join functions match by variables. B. Joining functions can join datasets of different dimensions, but the bind functions must match on the appropriate dimension (either same row or column numbers). C. Bind functions can combine both vectors and dataframes, while join functions work for only for dataframes. D. The join functions are a part of the dplyr package and have been optimized for speed, while the bind functions are inefficient base functions. We have two simple tables, shown below, with columns x and y: &gt; df1 x y a a b a &gt; df2 x y a a a b Which command would result in the following table? &gt; final x y b a A. final &lt;- union(df1, df2) B. final &lt;- setdiff(df1, df2) C. final &lt;- setdiff(df2, df1) D. final &lt;- intersect(df1, df2) Install and load the Lahman library. This library contains a variety of datasets related to US professional baseball. We will use this library for the next few questions and will discuss it more extensively in the Regression course. For now, focus on wrangling the data rather than understanding the statistics. The Batting data frame contains the offensive statistics for all baseball players over several seasons. Filter this data frame to define top as the top 10 home run (HR) hitters in 2016: if(!require(Lahman)) install.packages(&quot;Lahman&quot;) ## Loading required package: Lahman library(Lahman) top &lt;- Batting %&gt;% filter(yearID == 2016) %&gt;% arrange(desc(HR)) %&gt;% # arrange by descending HR count slice(1:10) # take entries 1-10 top %&gt;% as_tibble() ## # A tibble: 10 x 22 ## playerID yearID stint teamID lgID G AB R H X2B X3B HR RBI SB CS BB SO IBB HBP SH SF GIDP ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 trumbma01 2016 1 BAL AL 159 613 94 157 27 1 47 108 2 0 51 170 1 3 0 0 14 ## 2 cruzne02 2016 1 SEA AL 155 589 96 169 27 1 43 105 2 0 62 159 5 9 0 7 15 ## 3 daviskh01 2016 1 OAK AL 150 555 85 137 24 2 42 102 1 2 42 166 0 8 0 5 19 ## 4 doziebr01 2016 1 MIN AL 155 615 104 165 35 5 42 99 18 2 61 138 6 8 2 5 12 ## 5 encared01 2016 1 TOR AL 160 601 99 158 34 0 42 127 2 0 87 138 3 5 0 8 22 ## 6 arenano01 2016 1 COL NL 160 618 116 182 35 6 41 133 2 3 68 103 10 2 0 8 17 ## 7 cartech02 2016 1 MIL NL 160 549 84 122 27 1 41 94 3 1 76 206 1 9 0 10 18 ## 8 frazito01 2016 1 CHA AL 158 590 89 133 21 0 40 98 15 5 64 163 1 4 1 7 11 ## 9 bryankr01 2016 1 CHN NL 155 603 121 176 35 3 39 102 8 5 75 154 5 18 0 3 3 ## 10 canoro01 2016 1 SEA AL 161 655 107 195 33 2 39 103 0 1 47 100 8 8 0 5 18 Also Inspect the Master data frame, which has demographic information for all players: Master %&gt;% as_tibble() ## # A tibble: 19,878 x 26 ## playerID birthYear birthMonth birthDay birthCountry birthState birthCity deathYear deathMonth deathDay deathCountry deathState deathCity nameFirst nameLast nameGiven weight height ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 aardsda… 1981 12 27 USA CO Denver NA NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; David Aardsma David Al… 215 75 ## 2 aaronha… 1934 2 5 USA AL Mobile NA NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Hank Aaron Henry Lo… 180 72 ## 3 aaronto… 1939 8 5 USA AL Mobile 1984 8 16 USA GA Atlanta Tommie Aaron Tommie L… 190 75 ## 4 aasedo01 1954 9 8 USA CA Orange NA NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Don Aase Donald W… 190 75 ## 5 abadan01 1972 8 25 USA FL Palm Bea… NA NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Andy Abad Fausto A… 184 73 ## 6 abadfe01 1985 12 17 D.R. La Romana La Romana NA NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Fernando Abad Fernando… 220 73 ## 7 abadijo… 1850 11 4 USA PA Philadel… 1905 5 17 USA NJ Pemberton John Abadie John W. 192 72 ## 8 abbated… 1877 4 15 USA PA Latrobe 1957 1 6 USA FL Fort Lau… Ed Abbatic… Edward J… 170 71 ## 9 abbeybe… 1869 11 11 USA VT Essex 1962 6 11 USA VT Colchest… Bert Abbey Bert Wood 175 71 ## 10 abbeych… 1866 10 14 USA NE Falls Ci… 1926 4 27 USA CA San Fran… Charlie Abbey Charles … 169 68 ## # … with 19,868 more rows, and 8 more variables: bats &lt;fct&gt;, throws &lt;fct&gt;, debut &lt;chr&gt;, finalGame &lt;chr&gt;, retroID &lt;chr&gt;, bbrefID &lt;chr&gt;, deathDate &lt;date&gt;, birthDate &lt;date&gt; Use the correct join or bind function to create a combined table of the names and statistics of the top 10 home run (HR) hitters for 2016. This table should have the player ID, first name, last name, and number of HR for the top 10 players. Name this data frame top_names. Identify the join or bind that fills the blank in this code to create the correct table: top_names &lt;- top %&gt;% ___________________ %&gt;% select(playerID, nameFirst, nameLast, HR) Which bind or join function fills the blank to generate the correct table? top_names &lt;- top %&gt;% left_join(Master) %&gt;% select(playerID, nameFirst, nameLast, HR) ## Joining, by = &quot;playerID&quot; A. rbind(Master) B. cbind(Master) C. left_join(Master) D. right_join(Master) E. full_join(Master) F. anti_join(Master) Inspect the Salaries data frame. Filter this data frame to the 2016 salaries, then use the correct bind join function to add a salary column to the top_names data frame from the previous question. Name the new data frame top_salary. Use this code framework: top_salary &lt;- Salaries %&gt;% filter(yearID == 2016) %&gt;% ______________ %&gt;% select(nameFirst, nameLast, teamID, HR, salary) Which bind or join function fills the blank to generate the correct table? top_salary &lt;- Salaries %&gt;% filter(yearID == 2016) %&gt;% right_join(top_names) %&gt;% select(nameFirst, nameLast, teamID, HR, salary) A. rbind(top_names) B. cbind(top_names) C. left_join(top_names) D. right_join(top_names) E. full_join(top_names) F. anti_join(top_names) Inspect the AwardsPlayers table. Filter awards to include only the year 2016. How many players from the top 10 home run hitters won at least one award in 2016? Use a set operator. Awards_2016 &lt;- AwardsPlayers %&gt;% filter(yearID == 2016) length(intersect(Awards_2016$playerID, top_names$playerID)) ## [1] 3 How many players won an award in 2016 but were not one of the top 10 home run hitters in 2016? Use a set operator. length(setdiff(Awards_2016$playerID, top_names$playerID)) ## [1] 44 3.10 Web Scraping The textbook for this section is available here through section 23.2. Key points Web scraping is extracting data from a website. The rvest web harvesting package includes functions to extract nodes of an HTML document: html_nodes() extracts all nodes of different types, and html_node() extracts the first node. html_table() converts an HTML table to a data frame. Code # import a webpage into R if(!require(rvest)) install.packages(&quot;rvest&quot;) ## Loading required package: rvest ## Loading required package: xml2 ## ## Attaching package: &#39;rvest&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## pluck ## The following object is masked from &#39;package:readr&#39;: ## ## guess_encoding library(rvest) url &lt;- &quot;https://en.wikipedia.org/wiki/Murder_in_the_United_States_by_state&quot; h &lt;- read_html(url) class(h) ## [1] &quot;xml_document&quot; &quot;xml_node&quot; h ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\\n&lt;meta charset=&quot;UTF-8&quot;&gt;\\n&lt;title&gt;Gun violence in the United States by state - Wikipedia&lt;/title&gt;\\n&lt;sc ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-Gun_violence_in_the_United_States_by_state rootpage-Gun_violence_in_the_United_States ... tab &lt;- h %&gt;% html_nodes(&quot;table&quot;) tab &lt;- tab[[2]] tab &lt;- tab %&gt;% html_table class(tab) ## [1] &quot;data.frame&quot; tab &lt;- tab %&gt;% setNames(c(&quot;state&quot;, &quot;population&quot;, &quot;total&quot;, &quot;murders&quot;, &quot;gun_murders&quot;, &quot;gun_ownership&quot;, &quot;total_rate&quot;, &quot;murder_rate&quot;, &quot;gun_murder_rate&quot;)) head(tab) ## state population total murders gun_murders gun_ownership total_rate murder_rate gun_murder_rate ## 1 Alabama 4,853,875 348 —[a] —[a] 48.9 7.2 — [a] — [a] ## 2 Alaska 737,709 59 57 39 61.7 8.0 7.7 5.3 ## 3 Arizona 6,817,565 306 278 171 32.3 4.5 4.1 2.5 ## 4 Arkansas 2,977,853 181 164 110 57.9 6.1 5.5 3.7 ## 5 California 38,993,940 1,861 1,861 1,275 20.1 4.8 4.8 3.3 ## 6 Colorado 5,448,819 176 176 115 34.3 3.2 3.2 2.1 3.11 CSS Selectors This page corresponds to the textbook section on CSS selectors. The default look of webpages made with the most basic HTML is quite unattractive. The aesthetically pleasing pages we see today are made using CSS. CSS is used to add style to webpages. The fact that all pages for a company have the same style is usually a result that they all use the same CSS file. The general way these CSS files work is by defining how each of the elements of a webpage will look. The title, headings, itemized lists, tables, and links, for example, each receive their own style including font, color, size, and distance from the margin, among others. To do this CSS leverages patterns used to define these elements, referred to as selectors. An example of pattern we used in a previous video is table but there are many many more. If we want to grab data from a webpage and we happen to know a selector that is unique to the part of the page, we can use the html_nodes() function. However, knowing which selector to use can be quite complicated. To demonstrate this we will try to extract the recipe name, total preparation time, and list of ingredients from this guacamole recipe. Looking at the code for this page, it seems that the task is impossibly complex. However, selector gadgets actually make this possible. SelectorGadget is piece of software that allows you to interactively determine what CSS selector you need to extract specific components from the webpage. If you plan on scraping data other than tables, we highly recommend you install it. A Chrome extension is available which permits you to turn on the gadget highlighting parts of the page as you click through, showing the necessary selector to extract those segments. For the guacamole recipe page, we already have done this and determined that we need the following selectors: h &lt;- read_html(&quot;http://www.foodnetwork.com/recipes/alton-brown/guacamole-recipe-1940609&quot;) recipe &lt;- h %&gt;% html_node(&quot;.o-AssetTitle__a-HeadlineText&quot;) %&gt;% html_text() prep_time &lt;- h %&gt;% html_node(&quot;.m-RecipeInfo__a-Description--Total&quot;) %&gt;% html_text() ingredients &lt;- h %&gt;% html_nodes(&quot;.o-Ingredients__a-Ingredient&quot;) %&gt;% html_text() You can see how complex the selectors are. In any case we are now ready to extract what we want and create a list: guacamole &lt;- list(recipe, prep_time, ingredients) guacamole Since recipe pages from this website follow this general layout, we can use this code to create a function that extracts this information: get_recipe &lt;- function(url){ h &lt;- read_html(url) recipe &lt;- h %&gt;% html_node(&quot;.o-AssetTitle__a-HeadlineText&quot;) %&gt;% html_text() prep_time &lt;- h %&gt;% html_node(&quot;.m-RecipeInfo__a-Description--Total&quot;) %&gt;% html_text() ingredients &lt;- h %&gt;% html_nodes(&quot;.o-Ingredients__a-Ingredient&quot;) %&gt;% html_text() return(list(recipe = recipe, prep_time = prep_time, ingredients = ingredients)) } and then use it on any of their webpages: get_recipe(&quot;http://www.foodnetwork.com/recipes/food-network-kitchen/pancakes-recipe-1913844&quot;) There are several other powerful tools provided by rvest. For example, the functions html_form(), set_values(), and submit_form() permit you to query a webpage from R. This is a more advanced topic not covered here. 3.12 Assessment - Web Scraping Load the following web page, which contains information about Major League Baseball payrolls, into R: https://web.archive.org/web/20181024132313/http://www.stevetheump.com/Payrolls.htm url &lt;- &quot;https://web.archive.org/web/20181024132313/http://www.stevetheump.com/Payrolls.htm&quot; h &lt;- read_html(url) We learned that tables in html are associated with the table node. Use the html_nodes() function and the table node type to extract the first table. Store it in an object nodes: nodes &lt;- html_nodes(h, &quot;table&quot;) The html_nodes() function returns a list of objects of class xml_node. We can see the content of each one using, for example, the html_text() function. You can see the content for an arbitrarily picked component like this: html_text(nodes[[8]]) ## [1] &quot;Team\\nPayroll\\nAverge\\nMedianNew York Yankees\\n$ 197,962,289\\n$ 6,186,321\\n$ 1,937,500Philadelphia Phillies\\n$ 174,538,938\\n$ 5,817,964\\n$ 1,875,000Boston Red Sox\\n$ 173,186,617\\n$ 5,093,724\\n$ 1,556,250Los Angeles Angels\\n$ 154,485,166\\n$ 5,327,074\\n$ 3,150,000Detroit Tigers\\n$ 132,300,000\\n$ 4,562,068\\n$ 1,100,000Texas Rangers\\n$ 120,510,974\\n$ 4,635,037\\n$ 3,437,500Miami Marlins\\n$ 118,078,000\\n$ 4,373,259\\n$ 1,500,000San Francisco Giants\\n$ 117,620,683\\n$ 3,920,689\\n$ 1,275,000St. Louis Cardinals\\n$ 110,300,862\\n$ 3,939,316\\n$ 800,000Milwaukee Brewers\\n$ 97,653,944\\n$ 3,755,920\\n$ 1,981,250Chicago White Sox\\n$ 96,919,500\\n$ 3,876,780\\n$ 530,000Los Angeles Dodgers\\n$ 95,143,575\\n$ 3,171,452\\n$ 875,000Minnesota Twins\\n$ 94,085,000\\n$ 3,484,629\\n$ 750,000New York Mets\\n$ 93,353,983\\n$ 3,457,554\\n$ 875,000Chicago Cubs\\n$ 88,197,033\\n$ 3,392,193\\n$ 1,262,500Atlanta Braves\\n$ 83,309,942\\n$ 2,776,998\\n$ 577,500Cincinnati Reds\\n$ 82,203,616\\n$ 2,935,843\\n$ 1,150,000Seattle Mariners\\n$ 81,978,100\\n$ 2,927,789\\n$ 495,150Baltimore Orioles\\n$ 81,428,999\\n$ 2,807,896\\n$ 1,300,000Washington Nationals\\n$ 81,336,143\\n$ 2,623,746\\n$ 800,000Cleveland Indians\\n$ 78,430,300\\n$ 2,704,493\\n$ 800,000Colorado Rockies\\n$ 78,069,571\\n$ 2,692,054\\n$ 482,000Toronto Blue Jays\\n$ 75,489,200\\n$ 2,696,042\\n$ 1,768,750Arizona Diamondbacks\\n$ 74,284,833\\n$ 2,653,029\\n$ 1,625,000Tampa Bay Rays\\n$ 64,173,500\\n$ 2,291,910\\n$ 1,425,000Pittsburgh Pirates\\n$ 63,431,999\\n$ 2,187,310\\n$ 916,666Kansas City Royals\\n$ 60,916,225\\n$ 2,030,540\\n$ 870,000Houston Astros\\n$ 60,651,000\\n$ 2,332,730\\n$ 491,250Oakland Athletics\\n$ 55,372,500\\n$ 1,845,750\\n$ 487,500San Diego Padres\\n$ 55,244,700\\n$ 1,973,025\\n$ 1,207,500&quot; If the content of this object is an html table, we can use the html_table() function to convert it to a data frame: html_table(nodes[[8]]) ## Team Payroll Averge Median ## 1 New York Yankees $ 197,962,289 $ 6,186,321 $ 1,937,500 ## 2 Philadelphia Phillies $ 174,538,938 $ 5,817,964 $ 1,875,000 ## 3 Boston Red Sox $ 173,186,617 $ 5,093,724 $ 1,556,250 ## 4 Los Angeles Angels $ 154,485,166 $ 5,327,074 $ 3,150,000 ## 5 Detroit Tigers $ 132,300,000 $ 4,562,068 $ 1,100,000 ## 6 Texas Rangers $ 120,510,974 $ 4,635,037 $ 3,437,500 ## 7 Miami Marlins $ 118,078,000 $ 4,373,259 $ 1,500,000 ## 8 San Francisco Giants $ 117,620,683 $ 3,920,689 $ 1,275,000 ## 9 St. Louis Cardinals $ 110,300,862 $ 3,939,316 $ 800,000 ## 10 Milwaukee Brewers $ 97,653,944 $ 3,755,920 $ 1,981,250 ## 11 Chicago White Sox $ 96,919,500 $ 3,876,780 $ 530,000 ## 12 Los Angeles Dodgers $ 95,143,575 $ 3,171,452 $ 875,000 ## 13 Minnesota Twins $ 94,085,000 $ 3,484,629 $ 750,000 ## 14 New York Mets $ 93,353,983 $ 3,457,554 $ 875,000 ## 15 Chicago Cubs $ 88,197,033 $ 3,392,193 $ 1,262,500 ## 16 Atlanta Braves $ 83,309,942 $ 2,776,998 $ 577,500 ## 17 Cincinnati Reds $ 82,203,616 $ 2,935,843 $ 1,150,000 ## 18 Seattle Mariners $ 81,978,100 $ 2,927,789 $ 495,150 ## 19 Baltimore Orioles $ 81,428,999 $ 2,807,896 $ 1,300,000 ## 20 Washington Nationals $ 81,336,143 $ 2,623,746 $ 800,000 ## 21 Cleveland Indians $ 78,430,300 $ 2,704,493 $ 800,000 ## 22 Colorado Rockies $ 78,069,571 $ 2,692,054 $ 482,000 ## 23 Toronto Blue Jays $ 75,489,200 $ 2,696,042 $ 1,768,750 ## 24 Arizona Diamondbacks $ 74,284,833 $ 2,653,029 $ 1,625,000 ## 25 Tampa Bay Rays $ 64,173,500 $ 2,291,910 $ 1,425,000 ## 26 Pittsburgh Pirates $ 63,431,999 $ 2,187,310 $ 916,666 ## 27 Kansas City Royals $ 60,916,225 $ 2,030,540 $ 870,000 ## 28 Houston Astros $ 60,651,000 $ 2,332,730 $ 491,250 ## 29 Oakland Athletics $ 55,372,500 $ 1,845,750 $ 487,500 ## 30 San Diego Padres $ 55,244,700 $ 1,973,025 $ 1,207,500 You will analyze the tables from this HTML page over questions 1-3. Many tables on this page are team payroll tables, with columns for rank, team, and one or more money values. Convert the first four tables in nodes to data frames and inspect them. sapply(nodes[1:4], html_table) # 2, 3, 4 give tables with payroll info ## [[1]] ## X1 X2 ## 1 NA Salary Stats 1967-2019\\nTop ML Player Salaries / Baseball&#39;s Luxury Tax ## ## [[2]] ## RANK TEAM Payroll ## 1 1 Boston Red Sox $235.65M ## 2 2 San Francisco Giants $208.51M ## 3 3 Los Angeles Dodgers $186.14M ## 4 4 Chicago Cubs $183.46M ## 5 5 Washington Nationals $181.59M ## 6 6 Los Angeles Angels $175.1M ## 7 7 New York Yankees $168.54M ## 8 8 Seattle Mariners $162.48M ## 9 9 Toronto Blue Jays $162.316M ## 10 10 St. Louis Cardinals $161.01M ## 11 11 Houston Astros $160.04M ## 12 12 New York Mets $154.61M ## 13 13 Texas Rangers $144.0M ## 14 14 Baltimore Orioles $143.09M ## 15 15 Colorado Rockies $141.34M ## 16 16 Cleveland Indians $134.35M ## 17 17 Arizona Diamondbacks $132.5M ## 18 18 Minnesota Twins $131.91M ## 19 19 Detroit Tigers $129.92M ## 20 20 Kansas City Royals $129.92M ## 21 21 Atlanta Braves $120.54M ## 22 22 Cincinnati Reds $101.19M ## 23 23 Miami Marlins $98.64M ## 24 24 Philadelphia Phillies $96.85M ## 25 25 San Diego Padres $96.13M ## 26 26 Milwaukee Brewers $90.24M ## 27 27 Pittsburgh Pirates $87.88M ## 28 28 Tampa Bay Rays $78.73M ## 29 29 Chicago White Sox $72.18M ## 30 30 Oakland Athletics $68.53M ## ## [[3]] ## X1 X2 X3 X4 X5 ## 1 Rank Team 25 Man Disabled List Total Payroll ## 2 1 Los Angeles Dodgers $155,887,854 $37,354,166 $242,065,828 ## 3 2 New York Yankees $168,045,699 $5,644,000 $201,539,699 ## 4 3 Boston Red Sox $136,780,500 $38,239,250 $199,805,178 ## 5 4 Detroit Tigers $168,500,600 $11,750,000 $199,750,600 ## 6 5 Toronto Blue Jays $159,175,968 $2,169,400 $177,795,368 ## 7 6 Texas Rangers $115,162,703 $39,136,360 $175,909,063 ## 8 7 San Francisco Giants $169,504,611 $2,500,000 $172,354,611 ## 9 8 Chicago Cubs $170,189,880 $2,000,000 $172,189,880 ## 10 9 Washington Nationals $163,111,918 $535,000 $167,846,918 ## 11 10 Baltimore Orioles $142,066,615 $19,501,668 $163,676,616 ## 12 11 Los Angeles Angels of Anaheim $116,844,833 $17,120,500 $160,375,333 ## 13 12 New York Mets $120,870,470 $26,141,990 $155,187,460 ## 14 13 Seattle Mariners $139,257,018 $15,007,300 $154,800,918 ## 15 14 St. Louis Cardinals $136,181,533 $13,521,400 $152,452,933 ## 16 15 Kansas City Royals $127,333,150 $4,092,100 $140,925,250 ## 17 16 Colorado Rockies $86,909,571 $14,454,000 $130,963,571 ## 18 17 Cleveland Indians $101,105,399 $14,005,766 $124,861,165 ## 19 18 Houston Astros $117,957,800 $4,386,100 $124,343,900 ## 20 19 Atlanta Braves $103,303,791 $8,927,500 $112,437,541 ## 21 20 Miami Marlins $96,446,100 $15,035,000 $111,881,100 ## 22 21 Philadelphia Phillies $86,841,000 $537,000 $111,378,000 ## 23 22 Minnesota Twins $92,592,500 $8,735,000 $108,077,500 ## 24 23 Pittsburgh Pirates $92,362,832 - $100,575,946 ## 25 24 Chicago White Sox $95,625,000 $1,671,000 $99,119,770 ## 26 25 Cincinnati Reds $53,858,785 $26,910,000 $93,768,785 ## 27 26 Arizona Diamondbacks $91,481,600 $1,626,000 $93,257,600 ## 28 27 Oakland Athletics $64,339,166 $5,732,500 $81,738,333 ## 29 28 San Diego Padres $29,628,400 $4,946,000 $71,624,400 ## 30 29 Tampa Bay Rays $55,282,232 $14,680,300 $69,962,532 ## 31 30 Milwaukee Brewers $50,023,900 $13,037,400 $63,061,300 ## ## [[4]] ## Rank Team Opening Day Avg Salary Median ## 1 1 Dodgers $ 223,352,402 $ 7,445,080 $ 5,166,666 ## 2 2 Yankees $ 213,472,857 $ 7,361,133 $ 3,300,000 ## 3 3 Red Sox $ 182,161,414 $ 6,072,047 $ 3,500,000 ## 4 4 Tigers $ 172,282,250 $ 6,891,290 $ 3,000,000 ## 5 5 Giants $ 166,495,942 $ 5,946,284 $ 4,000,000 ## 6 6 Nationals $ 166,010,977 $ 5,724,516 $ 2,500,000 ## 7 7 Angels $ 146,449,583 $ 5,049,986 $ 1,312,500 ## 8 8 Rangers $ 144,307,373 $ 4,509,605 $ 937,500 ## 9 9 Phillies $ 133,048,000 $ 4,434,933 $ 700,000 ## 10 10 Blue Jays $ 126,369,628 $ 4,357,573 $ 1,650,000 ## 11 11 Mariners $ 122,706,842 $ 4,719,494 $ 2,252,500 ## 12 12 Cardinals $ 120,301,957 $ 4,455,628 $ 2,000,000 ## 13 13 Reds $ 116,732,284 $ 4,323,418 $ 2,350,000 ## 14 14 Cubs $ 116,654,522 $ 4,166,233 $ 2,515,000 ## 15 15 Orioles $ 115,587,632 $ 3,985,780 $ 2,750,000 ## 16 16 Royals $ 112,914,525 $ 4,032,662 $ 2,532,500 ## 17 17 Padres $ 112,895,700 $ 4,342,142 $ 763,500 ## 18 18 Twins $ 108,262,000 $ 4,163,923 $ 1,775,000 ## 19 19 Mets $ 99,626,453 $ 3,558,088 $ 669,562 ## 20 20 White Sox $ 98,712,867 $ 3,525,460 $ 1,250,000 ## 21 21 Brewers $ 98,683,035 $ 3,795,501 $ 529,750 ## 22 22 Rockies $ 98,261,171 $ 3,388,316 $ 1,087,600 ## 23 23 Braves $ 87,622,648 $ 2,920,755 $ 1,333,333 ## 24 24 Indians $ 86,339,067 $ 3,197,743 $ 1,940,000 ## 25 25 Pirates $ 85,885,832 $ 2,862,861 $ 1,279,166 ## 26 26 Marlins $ 84,637,500 $ 3,134,722 $ 1,925,000 ## 27 27 Athletics $ 80,279,166 $ 2,508,724 $ 648,750 ## 28 28 Rays $ 73,649,584 $ 2,454,986 $ 750,000 ## 29 29 Diamondbacks $ 70,762,833 $ 2,358,761 $ 663,000 ## 30 30 Astros $ 69,064,200 $ 2,466,579 $ 1,031,250 Which of the first four nodes are tables of team payroll? Check all correct answers. Look at table content, not column names. A. None of the above B. Table 1 C. Table 2 D. Table 3 E. Table 4 For the last 3 components of nodes, which of the following are true? Check all correct answers. html_table(nodes[[length(nodes)-2]]) ## X1 X2 X3 ## 1 Team Payroll Average ## 2 NY Yankees $109,791,893 $3,541,674 ## 3 Boston $109,558,908 $3,423,716 ## 4 Los Angeles $108,980,952 $3,757,964 ## 5 NY Mets $93,174,428 $3,327,658 ## 6 Cleveland $91,974,979 $3,065,833 ## 7 Atlanta $91,851,687 $2,962,958 ## 8 Texas $88,504,421 $2,854,981 ## 9 Arizona $81,206,513 $2,900,233 ## 10 St. Louis $77,270,855 $2,664,512 ## 11 Toronto $75,798,500 $2,707,089 ## 12 Seattle $75,652,500 $2,701,875 ## 13 Baltimore $72,426,328 $2,497,460 ## 14 Colorado $71,068,000 $2,632,148 ## 15 Chicago Cubs $64,015,833 $2,462,147 ## 16 San Francisco $63,332,667 $2,345,654 ## 17 Chicago White Sox $62,363,000 $2,309,741 ## 18 Houston $60,382,667 $2,236,395 ## 19 Tampa Bay $54,951,602 $2,035,245 ## 20 Pittsburgh $52,698,333 $1,699,946 ## 21 Detroit $49,831,167 $1,779,685 ## 22 Anaheim $46,568,180 $1,502,199 ## 23 Cincinnati $45,227,882 $1,739,534 ## 24 Milwaukee $43,089,333 $1,595,901 ## 25 Philadelphia $41,664,167 $1,602,468 ## 26 San Diego $38,333,117 $1,419,745 ## 27 Kansas City $35,643,000 $1,229,069 ## 28 Florida $35,504,167 $1,183,472 ## 29 Montreal $34,774,500 $1,159,150 ## 30 Oakland $33,810,750 $1,252,250 ## 31 Minnesota $24,350,000 $901,852 html_table(nodes[[length(nodes)-1]]) ## X1 X2 X3 ## 1 Team Payroll Average ## 2 NY Yankees $92,538,260 $3,190,974 ## 3 Los Angeles $88,124,286 $3,263,862 ## 4 Atlanta $84,537,836 $2,817,928 ## 5 Baltimore $81,447,435 $2,808,532 ## 6 Arizona $81,027,833 $2,893,851 ## 7 NY Mets $79,509,776 $3,180,391 ## 8 Boston $77,940,333 $2,598,011 ## 9 Cleveland $75,880,871 $2,918,495 ## 10 Texas $70,795,921 $2,722,920 ## 11 Tampa Bay $62,765,129 $2,024,682 ## 12 St. Louis $61,453,863 $2,276,069 ## 13 Colorado $61,111,190 $2,182,543 ## 14 Chicago Cubs $60,539,333 $2,017,978 ## 15 Seattle $58,915,000 $2,265,962 ## 16 Detroit $58,265,167 $2,157,969 ## 17 San Diego $54,821,000 $1,827,367 ## 18 San Francisco $53,737,826 $2,066,839 ## 19 Anaheim $51,464,167 $1,715,472 ## 20 Houston $51,289,111 $1,899,597 ## 21 Philadelphia $47,308,000 $1,631,310 ## 22 Cincinnati $46,867,200 $1,735,822 ## 23 Toronto $46,238,333 $1,778,397 ## 24 Milwaukee $36,505,333 $1,140,792 ## 25 Montreal $34,807,833 $1,200,270 ## 26 Oakland $31,971,333 $1,184,123 ## 27 Chicago White Sox $31,133,500 $1,073,569 ## 28 Pittsburgh $28,928,333 $1,112,628 ## 29 Kansas City $23,433,000 $836,893 ## 30 Florida $20,072,000 $692,138 ## 31 Minnesota $16,519,500 $635,365 html_table(nodes[[length(nodes)]]) ## X1 X2 X3 X4 ## 1 Year Minimum Average % Chg ## 2 2019 $555,000 - ## 3 2018 $545,000 $4,520,000 ## 4 2017 $535,000 $4,470,000 5.4 ## 5 2016 $507,500 $4,400,000 - ## 6 2015 $507,500 $4,250,000 - ## 7 2014 $507,500 $3,820,000 12.8 ## 8 2013 $480,000 $3,386,212 5.4 ## 9 2012 $480,000 $3,440,000 3.8 ## 10 2011 $414,500 $3,305,393 0.2 ## 11 2010 $400,000 $3,297,828 1.8 ## 12 2009 $400,000 $3,240,206 2.7 ## 13 2008 $390,000 $3,150,000 7.1 ## 14 2007 $380,000 $2,820,000 4.6 ## 15 2006 $327,000 $2,699,292 9 ## 16 2005 $316,000 $2,632,655 5.9 ## 17 2004 $300,000 $2,486,609 (-2.7) ## 18 2003 $300,000 $2,555,416 7.2 ## 19 2002 $200,000 $2,340,920 5.2 ## 20 2001 $200,000 $2,138,896 13.9 ## 21 2000 $200,000 $1,895,630 15.6 ## 22 1999 $200,000 $1,611,166 19.3 ## 23 1998 $170,000 $1,398,831 4.2 ## 24 1997 $150,000 $1,336,609 17.6 ## 25 1996 $122,667 $1,119,981 9.9 ## 26 1995 $109,000 $1,110,766 (-9.9) ## 27 1994 $109,000 $1,168,263 6.1 ## 28 1993 $109,000 $1,076,089 3.3 ## 29 1992 $109,000 $1,028,667 21.7 ## 30 1991 $100,000 $851,492 53.9 ## 31 1990 $100,000 $597,537 12.9 ## 32 1989 $68,000 $497,254 ## 33 1988 $62,500 $438,729 ## 34 1987 $62,500 $412,454 ## 35 1986 $60,000 $412,520 ## 36 1985 $60,000 $371,571 ## 37 1984 $40,000 $329,408 ## 38 1983 $35,000 $289,194 ## 39 1982 $33,500 $241,497 ## 40 1981 $32,500 $185,651 ## 41 1980 $30,000 $143,756 ## 42 1979 $21,000 $113,558 ## 43 1978 $21,000 $99,876 ## 44 1977 $19,000 $76,066 ## 45 1976 $19,000 $51,501 ## 46 1975 $16,000 $44,676 ## 47 1974 $15,000 $40,839 ## 48 1973 $15,000 $36,566 ## 49 1972 $13,500 $34,092 ## 50 1971 $12,750 $31,543 ## 51 1970 $12,000 $29,303 ## 52 1969 $10,000 $24,909 ## 53 1968 $10,000 N/A ## 54 1967 $6,000 $19,000 A. All three entries are tables. B. All three entries are tables of payroll per team. C. The last entry shows the average across all teams through time, not payroll per team. D. None of the three entries are tables of payroll per team. Create a table called tab_1 using entry 10 of nodes. Create a table called tab_2 using entry 19 of nodes. Note that the column names should be c(\"Team\", \"Payroll\", \"Average\"). You can see that these column names are actually in the first data row of each table, and that tab_1 has an extra first column No. that should be removed so that the column names for both tables match. Remove the extra column in tab_1, remove the first row of each dataset, and change the column names for each table to c(\"Team\", \"Payroll\", \"Average\"). Use a full_join() by the Team to combine these two tables. Note that some students, presumably because of system differences, have noticed that entry 18 instead of entry 19 of nodes gives them the tab_2 correctly; be sure to check entry 18 if entry 19 is giving you problems. How many rows are in the joined data table? tab_1 &lt;- html_table(nodes[[10]]) tab_2 &lt;- html_table(nodes[[19]]) col_names &lt;- c(&quot;Team&quot;, &quot;Payroll&quot;, &quot;Average&quot;) tab_1 &lt;- tab_1[-1, -1] tab_2 &lt;- tab_2[-1,] names(tab_2) &lt;- col_names names(tab_1) &lt;- col_names full_join(tab_1,tab_2, by = &quot;Team&quot;) ## Team Payroll.x Average.x Payroll.y Average.y ## 1 New York Yankees $206,333,389 $8,253,336 &lt;NA&gt; &lt;NA&gt; ## 2 Boston Red Sox $162,747,333 $5,611,977 &lt;NA&gt; &lt;NA&gt; ## 3 Chicago Cubs $146,859,000 $5,439,222 $64,015,833 $2,462,147 ## 4 Philadelphia Phillies $141,927,381 $5,068,835 &lt;NA&gt; &lt;NA&gt; ## 5 New York Mets $132,701,445 $5,103,902 &lt;NA&gt; &lt;NA&gt; ## 6 Detroit Tigers $122,864,929 $4,550,553 &lt;NA&gt; &lt;NA&gt; ## 7 Chicago White Sox $108,273,197 $4,164,354 $62,363,000 $2,309,741 ## 8 Los Angeles Angels $105,013,667 $3,621,161 &lt;NA&gt; &lt;NA&gt; ## 9 Seattle Mariners $98,376,667 $3,513,452 &lt;NA&gt; &lt;NA&gt; ## 10 San Francisco Giants $97,828,833 $3,493,887 &lt;NA&gt; &lt;NA&gt; ## 11 Minnesota Twins $97,559,167 $3,484,256 &lt;NA&gt; &lt;NA&gt; ## 12 Los Angeles Dodgers $94,945,517 $3,651,751 &lt;NA&gt; &lt;NA&gt; ## 13 St. Louis Cardinals $93,540,753 $3,741,630 &lt;NA&gt; &lt;NA&gt; ## 14 Houston Astros $92,355,500 $3,298,411 &lt;NA&gt; &lt;NA&gt; ## 15 Atlanta Braves $84,423,667 $3,126,802 &lt;NA&gt; &lt;NA&gt; ## 16 Colorado Rockies $84,227,000 $2,904,379 &lt;NA&gt; &lt;NA&gt; ## 17 Baltimore Orioles $81,612,500 $3,138,942 &lt;NA&gt; &lt;NA&gt; ## 18 Milwaukee Brewers $81,108,279 $2,796,837 &lt;NA&gt; &lt;NA&gt; ## 19 Cincinnati Reds $72,386,544 $2,784,098 &lt;NA&gt; &lt;NA&gt; ## 20 Kansas City Royals $72,267,710 $2,491,990 &lt;NA&gt; &lt;NA&gt; ## 21 Tampa Bay Rays $71,923,471 $2,663,832 &lt;NA&gt; &lt;NA&gt; ## 22 Toronto Blue Jays $62,689,357 $2,089,645 &lt;NA&gt; &lt;NA&gt; ## 23 Washington Nationals $61,425,000 $2,047,500 &lt;NA&gt; &lt;NA&gt; ## 24 Cleveland Indians $61,203,967 $2,110,482 &lt;NA&gt; &lt;NA&gt; ## 25 Arizona Diamondbacks $60,718,167 $2,335,314 &lt;NA&gt; &lt;NA&gt; ## 26 Florida Marlins $55,641,500 $2,060,796 &lt;NA&gt; &lt;NA&gt; ## 27 Texas Rangers $55,250,545 $1,905,191 &lt;NA&gt; &lt;NA&gt; ## 28 Oakland Athletics $51,654,900 $1,666,287 &lt;NA&gt; &lt;NA&gt; ## 29 San Diego Padres $37,799,300 $1,453,819 &lt;NA&gt; &lt;NA&gt; ## 30 Pittsburgh Pirates $34,943,000 $1,294,185 &lt;NA&gt; &lt;NA&gt; ## 31 NY Yankees &lt;NA&gt; &lt;NA&gt; $109,791,893 $3,541,674 ## 32 Boston &lt;NA&gt; &lt;NA&gt; $109,558,908 $3,423,716 ## 33 Los Angeles &lt;NA&gt; &lt;NA&gt; $108,980,952 $3,757,964 ## 34 NY Mets &lt;NA&gt; &lt;NA&gt; $93,174,428 $3,327,658 ## 35 Cleveland &lt;NA&gt; &lt;NA&gt; $91,974,979 $3,065,833 ## 36 Atlanta &lt;NA&gt; &lt;NA&gt; $91,851,687 $2,962,958 ## 37 Texas &lt;NA&gt; &lt;NA&gt; $88,504,421 $2,854,981 ## 38 Arizona &lt;NA&gt; &lt;NA&gt; $81,206,513 $2,900,233 ## 39 St. Louis &lt;NA&gt; &lt;NA&gt; $77,270,855 $2,664,512 ## 40 Toronto &lt;NA&gt; &lt;NA&gt; $75,798,500 $2,707,089 ## 41 Seattle &lt;NA&gt; &lt;NA&gt; $75,652,500 $2,701,875 ## 42 Baltimore &lt;NA&gt; &lt;NA&gt; $72,426,328 $2,497,460 ## 43 Colorado &lt;NA&gt; &lt;NA&gt; $71,068,000 $2,632,148 ## 44 San Francisco &lt;NA&gt; &lt;NA&gt; $63,332,667 $2,345,654 ## 45 Houston &lt;NA&gt; &lt;NA&gt; $60,382,667 $2,236,395 ## 46 Tampa Bay &lt;NA&gt; &lt;NA&gt; $54,951,602 $2,035,245 ## 47 Pittsburgh &lt;NA&gt; &lt;NA&gt; $52,698,333 $1,699,946 ## 48 Detroit &lt;NA&gt; &lt;NA&gt; $49,831,167 $1,779,685 ## 49 Anaheim &lt;NA&gt; &lt;NA&gt; $46,568,180 $1,502,199 ## 50 Cincinnati &lt;NA&gt; &lt;NA&gt; $45,227,882 $1,739,534 ## 51 Milwaukee &lt;NA&gt; &lt;NA&gt; $43,089,333 $1,595,901 ## 52 Philadelphia &lt;NA&gt; &lt;NA&gt; $41,664,167 $1,602,468 ## 53 San Diego &lt;NA&gt; &lt;NA&gt; $38,333,117 $1,419,745 ## 54 Kansas City &lt;NA&gt; &lt;NA&gt; $35,643,000 $1,229,069 ## 55 Florida &lt;NA&gt; &lt;NA&gt; $35,504,167 $1,183,472 ## 56 Montreal &lt;NA&gt; &lt;NA&gt; $34,774,500 $1,159,150 ## 57 Oakland &lt;NA&gt; &lt;NA&gt; $33,810,750 $1,252,250 ## 58 Minnesota &lt;NA&gt; &lt;NA&gt; $24,350,000 $901,852 The Wikipedia page on opinion polling for the Brexit referendum, in which the United Kingdom voted to leave the European Union in June 2016, contains several tables. One table contains the results of all polls regarding the referendum over 2016. Polls regarding the referendum over 2016 Use the rvest library to read the HTML from this Wikipedia page (make sure to copy both lines of the URL): url &lt;- &quot;https://en.wikipedia.org/w/index.php?title=Opinion_polling_for_the_United_Kingdom_European_Union_membership_referendum&amp;oldid=896735054&quot; Assign tab to be the html nodes of the “table” class. How many tables are in this Wikipedia page? tab &lt;- read_html(url) %&gt;% html_nodes(&quot;table&quot;) length(tab) ## [1] 39 Inspect the first several html tables using html_table() with the argument fill=TRUE (you can read about this argument in the documentation). Find the first table that has 9 columns with the first column named “Date(s) conducted”. What is the first table number to have 9 columns where the first column is named “Date(s) conducted”? tab[[5]] %&gt;% html_table(fill = TRUE) %&gt;% names() # inspect column names ## [1] &quot;Date(s) conducted&quot; &quot;Remain&quot; &quot;Leave&quot; &quot;Undecided&quot; &quot;Lead&quot; &quot;Sample&quot; &quot;Conducted by&quot; &quot;Polling type&quot; ## [9] &quot;Notes&quot; "],
["section-3-overview.html", "4 Section 3 Overview 4.1 String Parsing 4.2 Defining Strings: Single and Double Quotes and How to Escape 4.3 stringr Package 4.4 Case Study 1: US Murders Data 4.5 Assessment - String Processing Part 1 4.6 Case Study 2: Reported Heights 4.7 Regex 4.8 Character Classes, Anchors and Quantifiers 4.9 Search and Replace with Regex 4.10 Groups with Regex 4.11 Testing and Improving 4.12 Assessment - String Processing Part 2 4.13 Separate with Regex 4.14 Using Groups and Quantifiers 4.15 Putting it All Together 4.16 String Splitting 4.17 Case Study - Extracting a Table from a PDF 4.18 Recoding 4.19 Assessment - String Processing Part 3", " 4 Section 3 Overview In the String Processing section, we use case studies that help demonstrate how string processing is a powerful tool useful for overcoming many data wrangling challenges. You will see how the original raw data was processed to create the data frames we have used in courses throughout this series. This section is divided into three parts. After completing the String Processing section, you will be able to: Remove unwanted characters from text. Extract numeric values from text. Find and replace characters. Extract specific parts of strings. Convert free form text into more uniform formats. Split strings into multiple values. Use regular expressions (regex) to process strings. 4.1 String Parsing The textbook for this section is available here. Key points The most common tasks in string processing include: extracting numbers from strings removing unwanted characters from text finding and replacing characters extracting specific parts of strings converting free form text to more uniform formats splitting strings into multiple values The stringr package in the tidyverse contains string processing functions that follow a similar naming format (str_functionname) and are compatible with the pipe. Code # read in raw murders data from Wikipedia url &lt;- &quot;https://en.wikipedia.org/w/index.php?title=Gun_violence_in_the_United_States_by_state&amp;direction=prev&amp;oldid=810166167&quot; murders_raw &lt;- read_html(url) %&gt;% html_nodes(&quot;table&quot;) %&gt;% html_table() %&gt;% .[[1]] %&gt;% setNames(c(&quot;state&quot;, &quot;population&quot;, &quot;total&quot;, &quot;murder_rate&quot;)) # inspect data and column classes head(murders_raw) ## state population total murder_rate ## 1 Alabama 4,853,875 348 7.2 ## 2 Alaska 737,709 59 8.0 ## 3 Arizona 6,817,565 309 4.5 ## 4 Arkansas 2,977,853 181 6.1 ## 5 California 38,993,940 1,861 4.8 ## 6 Colorado 5,448,819 176 3.2 class(murders_raw$population) ## [1] &quot;character&quot; class(murders_raw$total) ## [1] &quot;character&quot; 4.2 Defining Strings: Single and Double Quotes and How to Escape The textbook for this section is available here. Key points Define a string by surrounding text with either single quotes or double quotes. To include a single quote inside a string, use double quotes on the outside. To include a double quote inside a string, use single quotes on the outside. The cat() function displays a string as it is represented inside R. To include a double quote inside of a string surrounded by double quotes, use the backslash () to escape the double quote. Escape a single quote to include it inside of a string defined by single quotes. We will see additional uses of the escape later. Code s &lt;- &quot;Hello!&quot; # double quotes define a string s &lt;- &#39;Hello!&#39; # single quotes define a string s &lt;- `Hello` # backquotes do not s &lt;- &quot;10&quot;&quot; # error - unclosed quotes s &lt;- &#39;10&quot;&#39; # correct # cat shows what the string actually looks like inside R cat(s) ## 10&quot; s &lt;- &quot;5&#39;&quot; cat(s) ## 5&#39; # to include both single and double quotes in string, escape with \\ s &lt;- &#39;5&#39;10&quot;&#39; # error s &lt;- &quot;5&#39;10&quot;&quot; # error # to include both single and double quotes in string, escape with \\ s &lt;- &#39;5\\&#39;10&quot;&#39; # correct cat(s) ## 5&#39;10&quot; s &lt;- &quot;5&#39;10\\&quot;&quot; # correct cat(s) ## 5&#39;10&quot; 4.3 stringr Package The textbook for this section is available here. Key points The main types of string processing tasks are detecting, locating, extracting and replacing elements of strings. The stringr package from the tidyverse includes a variety of string processing functions that begin with str_ and take the string as the first argument, which makes them compatible with the pipe. Code # murders_raw defined in web scraping section # direct conversion to numeric fails because of commas murders_raw$population[1:3] ## [1] &quot;4,853,875&quot; &quot;737,709&quot; &quot;6,817,565&quot; as.numeric(murders_raw$population[1:3]) ## Warning: NAs introduced by coercion ## [1] NA NA NA 4.4 Case Study 1: US Murders Data The textbook for this section is available here. Key points Use the str_detect() function to determine whether a string contains a certain pattern. Use the str_replace_all() function to replace all instances of one pattern with another pattern. To remove a pattern, replace with the empty string (\"\"). The parse_number() function removes punctuation from strings and converts them to numeric. mutate_at() performs the same transformation on the specified column numbers. Code # murders_raw was defined in the web scraping section # detect whether there are commas commas &lt;- function(x) any(str_detect(x, &quot;,&quot;)) murders_raw %&gt;% summarize_all(funs(commas)) ## Warning: `funs()` is deprecated as of dplyr 0.8.0. ## Please use a list of either functions or lambdas: ## ## # Simple named list: ## list(mean = mean, median = median) ## ## # Auto named with `tibble::lst()`: ## tibble::lst(mean, median) ## ## # Using lambdas ## list(~ mean(., trim = .2), ~ median(., na.rm = TRUE)) ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## state population total murder_rate ## 1 FALSE TRUE TRUE FALSE # replace commas with the empty string and convert to numeric test_1 &lt;- str_replace_all(murders_raw$population, &quot;,&quot;, &quot;&quot;) test_1 &lt;- as.numeric(test_1) # parse_number also removes commas and converts to numeric test_2 &lt;- parse_number(murders_raw$population) identical(test_1, test_2) ## [1] TRUE murders_new &lt;- murders_raw %&gt;% mutate_at(2:3, parse_number) murders_new %&gt;% head ## state population total murder_rate ## 1 Alabama 4853875 348 7.2 ## 2 Alaska 737709 59 8.0 ## 3 Arizona 6817565 309 4.5 ## 4 Arkansas 2977853 181 6.1 ## 5 California 38993940 1861 4.8 ## 6 Colorado 5448819 176 3.2 4.5 Assessment - String Processing Part 1 Which of the following is NOT an application of string parsing? A. Removing unwanted characters from text. B. Extracting numeric values from text. C. Formatting numbers and characters so they can easily be displayed in deliverables like papers and presentations. D. Splitting strings into multiple values. Which of the following commands would not give you an error in R? A. cat(\" LeBron James is 6’8\\\" \") B. cat(' LeBron James is 6'8\" ') C. cat(` LeBron James is 6'8\" `) D. cat(\" LeBron James is 6\\’8\" \") Which of the following are advantages of the stringr package over string processing functions in base R? Select all that apply. A. Base R functions are rarely used for string processing by data scientists so it’s not worth learning them. B. Functions in stringr all start with “str_”, which makes them easy to look up using autocomplete. C. Stringr functions work better with pipes. D. The order of arguments is more consistent in stringr functions than in base R. You have a dataframe of monthly sales and profits in R &gt; head(dat) # A tibble: 5 x 3 Month Sales Profit &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; January $128,568 $16,234 February $109,523 $12,876 March $115,468 $17,920 April $122,274 $15,825 May $117,921 $15,437 Which of the following commands could convert the sales and profits columns to numeric? Select all that apply. A. dat %&gt;% mutate_at(2:3, parse_number) B. dat %&gt;% mutate_at(2:3, as.numeric) C. dat %&gt;% mutate_all(parse_number) D. dat %&gt;% mutate_at(2:3, funs(str_replace_all(., c(\"\\\\$|,\"), \"\"))) %&gt;%mutate_at(2:3, as.numeric) 4.6 Case Study 2: Reported Heights The textbook for this section is available here. Key points In the raw heights data, many students did not report their height as the number of inches as requested. There are many entries with real height information but in the wrong format, which we can extract with string processing. When there are both text and numeric entries in a column, the column will be a character vector. Converting this column to numeric will result in NAs for some entries. To correct problematic entries, look for patterns that are shared across large numbers of entries, then define rules that identify those patterns and use these rules to write string processing tasks. Use suppressWarnings() to hide warning messages for a function. Code # load raw heights data and inspect data(reported_heights) class(reported_heights$height) ## [1] &quot;character&quot; # convert to numeric, inspect, count NAs x &lt;- as.numeric(reported_heights$height) ## Warning: NAs introduced by coercion head(x) ## [1] 75 70 68 74 61 65 sum(is.na(x)) ## [1] 81 # keep only entries that result in NAs reported_heights %&gt;% mutate(new_height = as.numeric(height)) %&gt;% filter(is.na(new_height)) %&gt;% head(n=10) ## Warning: Problem with `mutate()` input `new_height`. ## ℹ NAs introduced by coercion ## ℹ Input `new_height` is `as.numeric(height)`. ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## time_stamp sex height new_height ## 1 2014-09-02 15:16:28 Male 5&#39; 4&quot; NA ## 2 2014-09-02 15:16:37 Female 165cm NA ## 3 2014-09-02 15:16:52 Male 5&#39;7 NA ## 4 2014-09-02 15:16:56 Male &gt;9000 NA ## 5 2014-09-02 15:16:56 Male 5&#39;7&quot; NA ## 6 2014-09-02 15:17:09 Female 5&#39;3&quot; NA ## 7 2014-09-02 15:18:00 Male 5 feet and 8.11 inches NA ## 8 2014-09-02 15:19:48 Male 5&#39;11 NA ## 9 2014-09-04 00:46:45 Male 5&#39;9&#39;&#39; NA ## 10 2014-09-04 10:29:44 Male 5&#39;10&#39;&#39; NA # calculate cutoffs that cover 99.999% of human population alpha &lt;- 1/10^6 qnorm(1-alpha/2, 69.1, 2.9) ## [1] 83.28575 qnorm(alpha/2, 63.7, 2.7) ## [1] 50.49258 # keep only entries that either result in NAs or are outside the plausible range of heights not_inches &lt;- function(x, smallest = 50, tallest = 84){ inches &lt;- suppressWarnings(as.numeric(x)) ind &lt;- is.na(inches) | inches &lt; smallest | inches &gt; tallest ind } # number of problematic entries problems &lt;- reported_heights %&gt;% filter(not_inches(height)) %&gt;% .$height length(problems) ## [1] 292 # 10 examples of x&#39;y or x&#39;y&quot; or x&#39;y\\&quot; pattern &lt;- &quot;^\\\\d\\\\s*&#39;\\\\s*\\\\d{1,2}\\\\.*\\\\d*&#39;*\\&quot;*$&quot; str_subset(problems, pattern) %&gt;% head(n=10) %&gt;% cat ## 5&#39; 4&quot; 5&#39;7 5&#39;7&quot; 5&#39;3&quot; 5&#39;11 5&#39;9&#39;&#39; 5&#39;10&#39;&#39; 5&#39; 10 5&#39;5&quot; 5&#39;2&quot; # 10 examples of x.y or x,y pattern &lt;- &quot;^[4-6]\\\\s*[\\\\.|,]\\\\s*([0-9]|10|11)$&quot; str_subset(problems, pattern) %&gt;% head(n=10) %&gt;% cat ## 5.3 5.5 6.5 5.8 5.6 5,3 5.9 6,8 5.5 6.2 # 10 examples of entries in cm rather than inches ind &lt;- which(between(suppressWarnings(as.numeric(problems))/2.54, 54, 81) ) ind &lt;- ind[!is.na(ind)] problems[ind] %&gt;% head(n=10) %&gt;% cat ## 150 175 177 178 163 175 178 165 165 180 4.7 Regex The textbook for this section is available here through section 24.5.2. Key points A regular expression (regex) is a way to describe a specific pattern of characters of text. A set of rules has been designed to do this specifically and efficiently. stringr functions can take a regex as a pattern. str_detect() indicates whether a pattern is present in a string. The main difference between a regex and a regular string is that a regex can include special characters. The | symbol inside a regex means “or”. Use '\\\\d' to represent digits. The backlash is used to distinguish it from the character 'd'. In R, you must use two backslashes for digits in regular expressions; in some other languages, you will only use one backslash for regex special characters. str_view() highlights the first occurrence of a pattern, and the str_view_all() function highlights all occurrences of the pattern. Code # detect whether a comma is present pattern &lt;- &quot;,&quot; str_detect(murders_raw$total, pattern) # show the subset of strings including &quot;cm&quot; str_subset(reported_heights$height, &quot;cm&quot;) # use the &quot;or&quot; symbol inside a regex (|) yes &lt;- c(&quot;180 cm&quot;, &quot;70 inches&quot;) no &lt;- c(&quot;180&quot;, &quot;70&#39;&#39;&quot;) s &lt;- c(yes, no) str_detect(s, &quot;cm&quot;) | str_detect(s, &quot;inches&quot;) str_detect(s, &quot;cm|inches&quot;) # highlight the first occurrence of a pattern str_view(s, pattern) # highlight all instances of a pattern str_view_all(s, pattern) 4.8 Character Classes, Anchors and Quantifiers The textbook for this section is available here, here and here Key points Define strings to test your regular expressions, including some elements that match and some that do not. This allows you to check for the two types of errors: failing to match and matching incorrectly. Square brackets define character classes: groups of characters that count as matching the pattern. You can use ranges to define character classes, such as [0-9] for digits and [a-zA-Z] for all letters. Anchors define patterns that must start or end at specific places. ^ and $ represent the beginning and end of the string respectively. Curly braces are quantifiers that state how many times a certain character can be repeated in the pattern. \\\\d{1,2} matches exactly 1 or 2 consecutive digits. Code # s was defined in the previous section yes &lt;- c(&quot;5&quot;, &quot;6&quot;, &quot;5&#39;10&quot;, &quot;5 feet&quot;, &quot;4&#39;11&quot;) no &lt;- c(&quot;&quot;, &quot;.&quot;, &quot;Five&quot;, &quot;six&quot;) s &lt;- c(yes, no) pattern &lt;- &quot;\\\\d&quot; # [56] means 5 or 6 str_view(s, &quot;[56]&quot;) # [4-7] means 4, 5, 6 or 7 yes &lt;- as.character(4:7) no &lt;- as.character(1:3) s &lt;- c(yes, no) str_detect(s, &quot;[4-7]&quot;) # ^ means start of string, $ means end of string pattern &lt;- &quot;^\\\\d$&quot; yes &lt;- c(&quot;1&quot;, &quot;5&quot;, &quot;9&quot;) no &lt;- c(&quot;12&quot;, &quot;123&quot;, &quot; 1&quot;, &quot;a4&quot;, &quot;b&quot;) s &lt;- c(yes, no) str_view(s, pattern) # curly braces define quantifiers: 1 or 2 digits pattern &lt;- &quot;^\\\\d{1,2}$&quot; yes &lt;- c(&quot;1&quot;, &quot;5&quot;, &quot;9&quot;, &quot;12&quot;) no &lt;- c(&quot;123&quot;, &quot;a4&quot;, &quot;b&quot;) str_view(c(yes, no), pattern) # combining character class, anchors and quantifier pattern &lt;- &quot;^[4-7]&#39;\\\\d{1,2}\\&quot;$&quot; yes &lt;- c(&quot;5&#39;7\\&quot;&quot;, &quot;6&#39;2\\&quot;&quot;, &quot;5&#39;12\\&quot;&quot;) no &lt;- c(&quot;6,2\\&quot;&quot;, &quot;6.2\\&quot;&quot;,&quot;I am 5&#39;11\\&quot;&quot;, &quot;3&#39;2\\&quot;&quot;, &quot;64&quot;) str_detect(yes, pattern) str_detect(no, pattern) 4.9 Search and Replace with Regex The textbook for this section is available: searching and replacing with regex. white space. quantifiers: *, +, ?. Key points str_replace() replaces the first instance of the detected pattern with a specified string. Spaces are characters and R does not ignore them. Spaces are specified by the special character \\\\s. Additional quantifiers include *, + and ?. * means 0 or more instances of the previous character. ? means 0 or 1 instances. + means 1 or more instances. Before removing characters from strings with functions like str_replace() and str_replace_all(), consider whether that replacement would have unintended effects. Code # number of entries matching our desired pattern pattern &lt;- &quot;^[4-7]&#39;\\\\d{1,2}\\&quot;$&quot; sum(str_detect(problems, pattern)) # inspect examples of entries with problems problems[c(2, 10, 11, 12, 15)] %&gt;% str_view(pattern) str_subset(problems, &quot;inches&quot;) str_subset(problems, &quot;&#39;&#39;&quot;) # replace or remove feet/inches words before matching pattern &lt;- &quot;^[4-7]&#39;\\\\d{1,2}$&quot; problems %&gt;% str_replace(&quot;feet|ft|foot&quot;, &quot;&#39;&quot;) %&gt;% # replace feet, ft, foot with &#39; str_replace(&quot;inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% # remove all inches symbols str_detect(pattern) %&gt;% sum() # R does not ignore whitespace identical(&quot;Hi&quot;, &quot;Hi &quot;) # \\\\s represents whitespace pattern_2 &lt;- &quot;^[4-7]&#39;\\\\s\\\\d{1,2}\\&quot;$&quot; str_subset(problems, pattern_2) # * means 0 or more instances of a character yes &lt;- c(&quot;AB&quot;, &quot;A1B&quot;, &quot;A11B&quot;, &quot;A111B&quot;, &quot;A1111B&quot;) no &lt;- c(&quot;A2B&quot;, &quot;A21B&quot;) str_detect(yes, &quot;A1*B&quot;) str_detect(no, &quot;A1*B&quot;) # test how *, ? and + differ data.frame(string = c(&quot;AB&quot;, &quot;A1B&quot;, &quot;A11B&quot;, &quot;A111B&quot;, &quot;A1111B&quot;), none_or_more = str_detect(yes, &quot;A1*B&quot;), nore_or_once = str_detect(yes, &quot;A1?B&quot;), once_or_more = str_detect(yes, &quot;A1+B&quot;)) # update pattern by adding optional spaces before and after feet symbol pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*\\\\d{1,2}$&quot; problems %&gt;% str_replace(&quot;feet|ft|foot&quot;, &quot;&#39;&quot;) %&gt;% # replace feet, ft, foot with &#39; str_replace(&quot;inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% # remove all inches symbols str_detect(pattern) %&gt;% sum() 4.10 Groups with Regex The textbook for this section is available here. Key Points Groups are defined using parentheses. Once we define groups, we can use the function str_match() to extract the values these groups define. str_extract() extracts only strings that match a pattern, not the values defined by groups. You can refer to the ith group with \\\\i. For example, refer to the value in the second group with \\\\2. Code # define regex with and without groups pattern_without_groups &lt;- &quot;^[4-7],\\\\d*$&quot; pattern_with_groups &lt;- &quot;^([4-7]),(\\\\d*)$&quot; # create examples yes &lt;- c(&quot;5,9&quot;, &quot;5,11&quot;, &quot;6,&quot;, &quot;6,1&quot;) no &lt;- c(&quot;5&#39;9&quot;, &quot;,&quot;, &quot;2,8&quot;, &quot;6.1.1&quot;) s &lt;- c(yes, no) # demonstrate the effect of groups str_detect(s, pattern_without_groups) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE str_detect(s, pattern_with_groups) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE # demonstrate difference between str_match and str_extract str_match(s, pattern_with_groups) ## [,1] [,2] [,3] ## [1,] &quot;5,9&quot; &quot;5&quot; &quot;9&quot; ## [2,] &quot;5,11&quot; &quot;5&quot; &quot;11&quot; ## [3,] &quot;6,&quot; &quot;6&quot; &quot;&quot; ## [4,] &quot;6,1&quot; &quot;6&quot; &quot;1&quot; ## [5,] NA NA NA ## [6,] NA NA NA ## [7,] NA NA NA ## [8,] NA NA NA str_extract(s, pattern_with_groups) ## [1] &quot;5,9&quot; &quot;5,11&quot; &quot;6,&quot; &quot;6,1&quot; NA NA NA NA # improve the pattern to recognize more events pattern_with_groups &lt;- &quot;^([4-7]),(\\\\d*)$&quot; yes &lt;- c(&quot;5,9&quot;, &quot;5,11&quot;, &quot;6,&quot;, &quot;6,1&quot;) no &lt;- c(&quot;5&#39;9&quot;, &quot;,&quot;, &quot;2,8&quot;, &quot;6.1.1&quot;) s &lt;- c(yes, no) str_replace(s, pattern_with_groups, &quot;\\\\1&#39;\\\\2&quot;) ## [1] &quot;5&#39;9&quot; &quot;5&#39;11&quot; &quot;6&#39;&quot; &quot;6&#39;1&quot; &quot;5&#39;9&quot; &quot;,&quot; &quot;2,8&quot; &quot;6.1.1&quot; # final pattern pattern_with_groups &lt;-&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot; # combine stringr commands with the pipe str_subset(problems, pattern_with_groups) %&gt;% head ## [1] &quot;5.3&quot; &quot;5.25&quot; &quot;5.5&quot; &quot;6.5&quot; &quot;5.8&quot; &quot;5.6&quot; str_subset(problems, pattern_with_groups) %&gt;% str_replace(pattern_with_groups, &quot;\\\\1&#39;\\\\2&quot;) %&gt;% head ## [1] &quot;5&#39;3&quot; &quot;5&#39;25&quot; &quot;5&#39;5&quot; &quot;6&#39;5&quot; &quot;5&#39;8&quot; &quot;5&#39;6&quot; 4.11 Testing and Improving The textbook for this section is available here. Key points Wrangling with regular expressions is often an iterative process of testing the approach, looking for problematic entries, and improving the patterns. Use the pipe to connect stringr functions. It may not be worth writing code to correct every unique problem in the data, but string processing techniques are flexible enough for most needs. Code # function to detect entries with problems not_inches_or_cm &lt;- function(x, smallest = 50, tallest = 84){ inches &lt;- suppressWarnings(as.numeric(x)) ind &lt;- !is.na(inches) &amp; ((inches &gt;= smallest &amp; inches &lt;= tallest) | (inches/2.54 &gt;= smallest &amp; inches/2.54 &lt;= tallest)) !ind } # identify entries with problems problems &lt;- reported_heights %&gt;% filter(not_inches_or_cm(height)) %&gt;% .$height length(problems) ## [1] 200 converted &lt;- problems %&gt;% str_replace(&quot;feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% #convert feet symbols to &#39; str_replace(&quot;inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% #remove inches symbols str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) ##change format # find proportion of entries that fit the pattern after reformatting pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*\\\\d{1,2}$&quot; index &lt;- str_detect(converted, pattern) mean(index) ## [1] 0.615 converted[!index] # show problems ## [1] &quot;6&quot; &quot;165cm&quot; &quot;511&quot; &quot;6&quot; &quot;2&quot; &quot;&gt;9000&quot; &quot;5 &#39; and 8.11 &quot; &quot;11111&quot; &quot;6&quot; &quot;103.2&quot; &quot;19&quot; ## [12] &quot;5&quot; &quot;300&quot; &quot;6&#39;&quot; &quot;6&quot; &quot;Five &#39; eight &quot; &quot;7&quot; &quot;214&quot; &quot;6&quot; &quot;0.7&quot; &quot;6&quot; &quot;2&#39;33&quot; ## [23] &quot;612&quot; &quot;1,70&quot; &quot;87&quot; &quot;5&#39;7.5&quot; &quot;5&#39;7.5&quot; &quot;111&quot; &quot;5&#39; 7.78&quot; &quot;12&quot; &quot;6&quot; &quot;yyy&quot; &quot;89&quot; ## [34] &quot;34&quot; &quot;25&quot; &quot;6&quot; &quot;6&quot; &quot;22&quot; &quot;684&quot; &quot;6&quot; &quot;1&quot; &quot;1&quot; &quot;6*12&quot; &quot;87&quot; ## [45] &quot;6&quot; &quot;1.6&quot; &quot;120&quot; &quot;120&quot; &quot;23&quot; &quot;1.7&quot; &quot;6&quot; &quot;5&quot; &quot;69&quot; &quot;5&#39; 9 &quot; &quot;5 &#39; 9 &quot; ## [56] &quot;6&quot; &quot;6&quot; &quot;86&quot; &quot;708,661&quot; &quot;5 &#39; 6 &quot; &quot;6&quot; &quot;649,606&quot; &quot;10000&quot; &quot;1&quot; &quot;728,346&quot; &quot;0&quot; ## [67] &quot;6&quot; &quot;6&quot; &quot;6&quot; &quot;100&quot; &quot;88&quot; &quot;6&quot; &quot;170 cm&quot; &quot;7,283,465&quot; &quot;5&quot; &quot;5&quot; &quot;34&quot; 4.12 Assessment - String Processing Part 2 In the video, we use the function not_inches to identify heights that were incorrectly entered not_inches &lt;- function(x, smallest = 50, tallest = 84) { inches &lt;- suppressWarnings(as.numeric(x)) ind &lt;- is.na(inches) | inches &lt; smallest | inches &gt; tallest ind } In this function, what TWO types of values are identified as not being correctly formatted in inches? A. Values that specifically contain apostrophes (‘), periods (.) or quotations (“). B. Values that result in NA’s when converted to numeric C. Values less than 50 inches or greater than 84 inches D. Values that are stored as a character class, because most are already classed as numeric. Which of the following arguments, when passed to the function not_inches, would return the vector c(FALSE)? A. c(175) B. c(“5’8\\””) C. c(70) D. c(85) (the height of Shaquille O’Neal in inches) Our function not_inches returns the object ind. Which answer correctly describes ind? A. ind is a logical vector of TRUE and FALSE, equal in length to the vector x (in the arguments list). TRUE indicates that a height entry is incorrectly formatted. B. ind is a logical vector of TRUE and FALSE, equal in length to the vector x (in the arguments list). TRUE indicates that a height entry is correctly formatted. C. ind is a data frame like our reported_heights table but with an extra column of TRUE or FALSE. TRUE indicates that a height entry is incorrectly formatted. D. ind is a numeric vector equal to reported_heights$heights but with incorrectly formatted heights replaced with NAs. Given the following code s &lt;- c(&quot;70&quot;, &quot;5 ft&quot;, &quot;4&#39;11&quot;, &quot;&quot;, &quot;.&quot;, &quot;Six feet&quot;) s ## [1] &quot;70&quot; &quot;5 ft&quot; &quot;4&#39;11&quot; &quot;&quot; &quot;.&quot; &quot;Six feet&quot; What pattern vector yields the following result? str_view_all(s, pattern) 70 5 ft 4’11 . Six feet pattern &lt;- &quot;\\\\d|ft&quot; str_view_all(s, pattern) A. pattern &lt;- \"\\\\d|ft\" B. pattern &lt;- \"\\d|ft\" C. pattern &lt;- \"\\\\d\\\\d|ft\" D. pattern &lt;- \"\\\\d|feet\" You enter the following set of commands into your R console. What is your printed result? animals &lt;- c(&quot;cat&quot;, &quot;puppy&quot;, &quot;Moose&quot;, &quot;MONKEY&quot;) pattern &lt;- &quot;[a-z]&quot; str_detect(animals, pattern) ## [1] TRUE TRUE TRUE FALSE A. TRUE B. TRUE TRUE TRUE TRUE C. TRUE TRUE TRUE FALSE D. TRUE TRUE FALSE FALSE You enter the following set of commands into your R console. What is your printed result? animals &lt;- c(&quot;cat&quot;, &quot;puppy&quot;, &quot;Moose&quot;, &quot;MONKEY&quot;) pattern &lt;- &quot;[A-Z]$&quot; str_detect(animals, pattern) ## [1] FALSE FALSE FALSE TRUE A. FALSE FALSE FALSE FALSE B. FALSE FALSE TRUE TRUE C. FALSE FALSE FALSE TRUE D. TRUE TRUE TRUE FALSE You enter the following set of commands into your R console. What is your printed result? animals &lt;- c(&quot;cat&quot;, &quot;puppy&quot;, &quot;Moose&quot;, &quot;MONKEY&quot;) pattern &lt;- &quot;[a-z]{4,5}&quot; str_detect(animals, pattern) ## [1] FALSE TRUE TRUE FALSE A. FALSE TRUE TRUE FALSE B. TRUE TRUE FALSE FALSE C. FALSE FALSE FALSE TRUE D. TRUE TRUE TRUE FALSE Given the following code animals &lt;- c(“moose”, “monkey”, “meerkat”, “mountain lion”) ------------ str_detect(animals, pattern) Which TWO “pattern” vectors would yield the following result? [1] TRUE TRUE TRUE TRUE animals &lt;- c(&quot;moose&quot;, &quot;monkey&quot;, &quot;meerkat&quot;, &quot;mountain lion&quot;) pattern &lt;- &quot;mo*&quot; str_detect(animals, pattern) ## [1] TRUE TRUE TRUE TRUE animals &lt;- c(&quot;moose&quot;, &quot;monkey&quot;, &quot;meerkat&quot;, &quot;mountain lion&quot;) pattern &lt;- &quot;mo?&quot; str_detect(animals, pattern) ## [1] TRUE TRUE TRUE TRUE A. pattern &lt;- \"mo*\" B. pattern &lt;- \"mo?\" C. pattern &lt;- \"mo+\" D. pattern &lt;- \"moo*\" You are working on some data from different universities. You have the following vector schools &lt;- c(&quot;U. Kentucky&quot;, &quot;Univ New Hampshire&quot;, &quot;Univ. of Massachusetts&quot;, &quot;University Georgia&quot;, &quot;U California&quot;, &quot;California State University&quot;) schools ## [1] &quot;U. Kentucky&quot; &quot;Univ New Hampshire&quot; &quot;Univ. of Massachusetts&quot; &quot;University Georgia&quot; &quot;U California&quot; ## [6] &quot;California State University&quot; You want to clean this data to match the full names of each university &gt; final [1] &quot;University of Kentucky&quot; &quot;University of New Hampshire&quot; &quot;University of Massachusetts&quot; &quot;University of Georgia&quot; [5] &quot;University of California&quot; &quot;California State University&quot; What of the following commands could accomplish this? schools %&gt;% str_replace(&quot;^Univ\\\\.?\\\\s|^U\\\\.?\\\\s&quot;, &quot;University &quot;) %&gt;% str_replace(&quot;^University of |^University &quot;, &quot;University of &quot;) ## [1] &quot;University of Kentucky&quot; &quot;University of New Hampshire&quot; &quot;University of Massachusetts&quot; &quot;University of Georgia&quot; &quot;University of California&quot; ## [6] &quot;California State University&quot; A. schools %&gt;% str_replace(&quot;Univ\\\\.?|U\\\\.?&quot;, &quot;University &quot;) %&gt;% str_replace(&quot;^University of |^University &quot;, &quot;University of &quot;) B. schools %&gt;% str_replace(&quot;^Univ\\\\.?\\\\s|^U\\\\.?\\\\s&quot;, &quot;University &quot;) %&gt;% str_replace(&quot;^University of |^University &quot;, &quot;University of &quot;) C. schools %&gt;% str_replace(&quot;^Univ\\\\.\\\\s|^U\\\\.\\\\s&quot;, &quot;University&quot;) %&gt;% str_replace(&quot;^University of |^University &quot;, &quot;University of &quot;) D. schools %&gt;% str_replace(&quot;^Univ\\\\.?\\\\s|^U\\\\.?\\\\s&quot;, &quot;University&quot;) %&gt;% str_replace(&quot;University &quot;, &quot;University of &quot;) Rather than using the pattern_with_groups vector, you accidentally write in the following code problems &lt;- c(&quot;5.3&quot;, &quot;5,5&quot;, &quot;6 1&quot;, &quot;5 .11&quot;, &quot;5, 12&quot;) pattern_with_groups &lt;- &quot;^([4-7])[,\\\\.](\\\\d*)$&quot; str_replace(problems, pattern_with_groups, &quot;\\\\1&#39;\\\\2&quot;) ## [1] &quot;5&#39;3&quot; &quot;5&#39;5&quot; &quot;6 1&quot; &quot;5 .11&quot; &quot;5, 12&quot; What is your result? A. [1] \"5'3\" \"5'5\" \"6 1\" \"5 .11\" \"5, 12\" B. [1] “5.3” “5,5” “6 1” “5 .11” “5, 12” C. [1] “5’3” “5’5” “6’1” “5 .11” “5, 12” D. [1] “5’3” “5’5” “6’1” “5’11” “5’12” You notice your mistake and correct your pattern regex to the following problems &lt;- c(&quot;5.3&quot;, &quot;5,5&quot;, &quot;6 1&quot;, &quot;5 .11&quot;, &quot;5, 12&quot;) pattern_with_groups &lt;- &quot;^([4-7])[,\\\\.\\\\s](\\\\d*)$&quot; str_replace(problems, pattern_with_groups, &quot;\\\\1&#39;\\\\2&quot;) ## [1] &quot;5&#39;3&quot; &quot;5&#39;5&quot; &quot;6&#39;1&quot; &quot;5 .11&quot; &quot;5, 12&quot; What is your result? A. [1] “5’3” “5’5” “6 1” “5 .11” “5, 12” B. [1] “5.3” “5,5” “6 1” “5 .11” “5, 12” C. [1] \"5'3\" \"5'5\" \"6'1\" \"5 .11\" \"5, 12\" D. [1] “5’3” “5’5” “6’1” “5’11” “5’12” In our example, we use the following code to detect height entries that do not match our pattern of x’y”. converted &lt;- problems %&gt;% str_replace(&quot;feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% str_replace(&quot;inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*\\\\d{1,2}$&quot; index &lt;- str_detect(converted, pattern) converted[!index] ## character(0) Which answer best describes the differences between the regex string we use as an argument in str_replace(\"^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$\", \"\\\\1'\\\\2\") and the regex string in pattern &lt;- \"^[4-7]\\\\s*'\\\\s*\\\\d{1,2}$\"? A. The regex used in str_replace() looks for either a comma, period or space between the feet and inches digits, while the pattern regex just looks for an apostrophe; the regex in str_replace allows for one or more digits to be entered as inches, while the pattern regex only allows for one or two digits. B. The regex used in str_replace() allows for additional spaces between the feet and inches digits, but the pattern regex does not. C. The regex used in str_replace() looks for either a comma, period or space between the feet and inches digits, while the pattern regex just looks for an apostrophe; the regex in str_replace allows none or more digits to be entered as inches, while the pattern regex only allows for the number 1 or 2 to be used. D. The regex used in str_replace() looks for either a comma, period or space between the feet and inches digits, while the pattern regex just looks for an apostrophe; the regex in str_replace allows for none or more digits to be entered as inches, while the pattern regex only allows for one or two digits. You notice a few entries that are not being properly converted using your str_replace and str_detect code yes &lt;- c(&quot;5 feet 7inches&quot;, &quot;5 7&quot;) no &lt;- c(&quot;5ft 9 inches&quot;, &quot;5 ft 9 inches&quot;) s &lt;- c(yes, no) converted &lt;- s %&gt;% str_replace(&quot;feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% str_replace(&quot;inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*\\\\d{1,2}$&quot; str_detect(converted, pattern) [1] TRUE TRUE FALSE FALSE It seems like the problem may be due to spaces around the words feet|foot|ft and inches|in. What is another way you could fix this problem? yes &lt;- c(&quot;5 feet 7inches&quot;, &quot;5 7&quot;) no &lt;- c(&quot;5ft 9 inches&quot;, &quot;5 ft 9 inches&quot;) s &lt;- c(yes, no) converted &lt;- s %&gt;% str_replace(&quot;\\\\s*(feet|foot|ft)\\\\s*&quot;, &quot;&#39;&quot;) %&gt;% str_replace(&quot;\\\\s*(inches|in|&#39;&#39;|\\&quot;)\\\\s*&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*\\\\d{1,2}$&quot; str_detect(converted, pattern) ## [1] TRUE TRUE TRUE TRUE A. converted &lt;- s %&gt;% str_replace(&quot;\\\\s*(feet|foot|ft)\\\\s*&quot;, &quot;&#39;&quot;) %&gt;% str_replace(&quot;\\\\s*(inches|in|&#39;&#39;|\\&quot;)\\\\s*&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) B. converted &lt;- s %&gt;% str_replace(&quot;\\\\s+feet|foot|ft\\\\s+”, &quot;&#39;&quot;) %&gt;% str_replace(&quot;\\\\s+inches|in|&#39;&#39;|\\&quot;\\\\s+&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) C. converted &lt;- s %&gt;% str_replace(&quot;\\\\s*|feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% str_replace(&quot;\\\\s*|inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) D. converted &lt;- s %&gt;% str_replace_all(“\\\\s”, “”) %&gt;% str_replace(&quot;\\\\s|feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% str_replace(&quot;\\\\s|inches|in|&#39;&#39;|\\&quot;&quot;, &quot;&quot;) %&gt;% str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) 4.13 Separate with Regex The textbook for this section is available here. Key Point The extract() function behaves similarly to the separate() function but allows extraction of groups from regular expressions. Code # first example - normally formatted heights s &lt;- c(&quot;5&#39;10&quot;, &quot;6&#39;1&quot;) tab &lt;- data.frame(x = s) # the separate and extract functions behave similarly tab %&gt;% separate(x, c(&quot;feet&quot;, &quot;inches&quot;), sep = &quot;&#39;&quot;) ## feet inches ## 1 5 10 ## 2 6 1 tab %&gt;% extract(x, c(&quot;feet&quot;, &quot;inches&quot;), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})&quot;) ## feet inches ## 1 5 10 ## 2 6 1 # second example - some heights with unusual formats s &lt;- c(&quot;5&#39;10&quot;, &quot;6&#39;1\\&quot;&quot;,&quot;5&#39;8inches&quot;) tab &lt;- data.frame(x = s) # separate fails because it leaves in extra characters, but extract keeps only the digits because of regex groups tab %&gt;% separate(x, c(&quot;feet&quot;,&quot;inches&quot;), sep = &quot;&#39;&quot;, fill = &quot;right&quot;) ## feet inches ## 1 5 10 ## 2 6 1&quot; ## 3 5 8inches tab %&gt;% extract(x, c(&quot;feet&quot;, &quot;inches&quot;), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})&quot;) ## feet inches ## 1 5 10 ## 2 6 1 ## 3 5 8 4.14 Using Groups and Quantifiers The textbook for this section is available here; through 24.10. Four clear patterns of entries have arisen along with some other minor problems: Many students measuring exactly 5 or 6 feet did not enter any inches. For example, 6’ - our pattern requires that inches be included. Some students measuring exactly 5 or 6 feet entered just that number. Some of the inches were entered with decimal points. For example 5’7.5’’. Our pattern only looks for two digits. Some entires have spaces at the end, for example 5 ’ 9. Some entries are in meters and some of these use European decimals: 1.6, 1,7. Two students added cm. One student spelled out the numbers: Five foot eight inches. It is not necessarily clear that it is worth writing code to handle all these cases since they might be rare enough. However, some give us an opportunity to learn some more regex techniques so we will build a fix. Case 1 For case 1, if we add a ’0 to, for example, convert all 6 to 6’0, then our pattern will match. This can be done using groups using the following code: yes &lt;- c(&quot;5&quot;, &quot;6&quot;, &quot;5&quot;) no &lt;- c(&quot;5&#39;&quot;, &quot;5&#39;&#39;&quot;, &quot;5&#39;4&quot;) s &lt;- c(yes, no) str_replace(s, &quot;^([4-7])$&quot;, &quot;\\\\1&#39;0&quot;) The pattern says it has to start (^), be followed with a digit between 4 and 7, and then end there ($). The parenthesis defines the group that we pass as \\1 to the replace regex. Cases 2 and 4 We can adapt this code slightly to handle case 2 as well which covers the entry 5’. Note that the 5’ is left untouched by the code above. This is because the extra ’ makes the pattern not match since we have to end with a 5 or 6. To handle case 2, we want to permit the 5 or 6 to be followed by no or one symbol for feet. So we can simply add ’{0,1} after the ’ to do this. We can also use the none or once special character ?. As we saw previously, this is different from * which is none or more. We now see that this code also handles the fourth case as well: str_replace(s, &quot;^([56])&#39;?$&quot;, &quot;\\\\1&#39;0&quot;) Note that here we only permit 5 and 6 but not 4 and 7. This is because heights of exactly 5 and exactly 6 feet tall are quite common, so we assume those that typed 5 or 6 really meant either 60 or 72 inches. However, heights of exactly 4 or exactly 7 feet tall are so rare that, although we accept 84 as a valid entry, we assume that a 7 was entered in error. Case 3 We can use quantifiers to deal with case 3. These entries are not matched because the inches include decimals and our pattern does not permit this. We need allow the second group to include decimals and not just digits. This means we must permit zero or one period . followed by zero or more digits. So we will use both ? and *. Also remember that for this particular case, the period needs to be escaped since it is a special character (it means any character except a line break). So we can adapt our pattern, currently ^[4-7]\\\\s*'\\\\s*\\\\d{1,2}$, to permit a decimal at the end: pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*(\\\\d+\\\\.?\\\\d*)$&quot; Case 5 Case 5, meters using commas, we can approach similarly to how we converted the x.y to x’y. A difference is that we require that the first digit is 1 or 2: yes &lt;- c(&quot;1,7&quot;, &quot;1, 8&quot;, &quot;2, &quot; ) no &lt;- c(&quot;5,8&quot;, &quot;5,3,2&quot;, &quot;1.7&quot;) s &lt;- c(yes, no) str_replace(s, &quot;^([12])\\\\s*,\\\\s*(\\\\d*)$&quot;, &quot;\\\\1\\\\.\\\\2&quot;) We will later check if the entries are meters using their numeric values. Trimming In general, spaces at the start or end of the string are uninformative. These can be particularly deceptive because sometimes they can be hard to see: s &lt;- &quot;Hi &quot; cat(s) identical(s, &quot;Hi&quot;) This is a general enough problem that there is a function dedicated to removing them: str_trim. str_trim(&quot;5 &#39; 9 &quot;) To upper and to lower case One of the entries writes out numbers as words: Five foot eight inches. Although not efficient, we could add 12 extra str_replace to convert zero to 0, one to 1, and so on. To avoid having to write two separate operations for Zero and zero, One and one, etc., we can use the str_to_lower() function to make all words lower case first: s &lt;- c(&quot;Five feet eight inches&quot;) str_to_lower(s) Putting it into a function We are now ready to define a procedure that handles converting all the problematic cases. We can now put all this together into a function that takes a string vector and tries to convert as many strings as possible to a single format. Below is a function that puts together the previous code replacements: convert_format &lt;- function(s){ s %&gt;% str_replace(&quot;feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% #convert feet symbols to &#39; str_replace_all(&quot;inches|in|&#39;&#39;|\\&quot;|cm|and&quot;, &quot;&quot;) %&gt;% #remove inches and other symbols str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) %&gt;% #change x.y, x,y x y str_replace(&quot;^([56])&#39;?$&quot;, &quot;\\\\1&#39;0&quot;) %&gt;% #add 0 when to 5 or 6 str_replace(&quot;^([12])\\\\s*,\\\\s*(\\\\d*)$&quot;, &quot;\\\\1\\\\.\\\\2&quot;) %&gt;% #change european decimal str_trim() #remove extra space } We can also write a function that converts words to numbers: words_to_numbers &lt;- function(s){ str_to_lower(s) %&gt;% str_replace_all(&quot;zero&quot;, &quot;0&quot;) %&gt;% str_replace_all(&quot;one&quot;, &quot;1&quot;) %&gt;% str_replace_all(&quot;two&quot;, &quot;2&quot;) %&gt;% str_replace_all(&quot;three&quot;, &quot;3&quot;) %&gt;% str_replace_all(&quot;four&quot;, &quot;4&quot;) %&gt;% str_replace_all(&quot;five&quot;, &quot;5&quot;) %&gt;% str_replace_all(&quot;six&quot;, &quot;6&quot;) %&gt;% str_replace_all(&quot;seven&quot;, &quot;7&quot;) %&gt;% str_replace_all(&quot;eight&quot;, &quot;8&quot;) %&gt;% str_replace_all(&quot;nine&quot;, &quot;9&quot;) %&gt;% str_replace_all(&quot;ten&quot;, &quot;10&quot;) %&gt;% str_replace_all(&quot;eleven&quot;, &quot;11&quot;) } Now we can see which problematic entries remain: converted &lt;- problems %&gt;% words_to_numbers %&gt;% convert_format remaining_problems &lt;- converted[not_inches_or_cm(converted)] pattern &lt;- &quot;^[4-7]\\\\s*&#39;\\\\s*\\\\d+\\\\.?\\\\d*$&quot; index &lt;- str_detect(remaining_problems, pattern) remaining_problems[!index] 4.15 Putting it All Together We are now ready to put everything we’ve done so far together and wrangle our reported heights data as we try to recover as many heights as possible. The code is complex but we will break it down into parts. We start by cleaning up the height column so that the heights are closer to a feet’inches format. We added an original heights column so we can compare before and after. Let’s start by writing a function that cleans up strings so that all the feet and inches formats use the same x’y format when appropriate. pattern &lt;- &quot;^([4-7])\\\\s*&#39;\\\\s*(\\\\d+\\\\.?\\\\d*)$&quot; convert_format &lt;- function(s){ s %&gt;% str_replace(&quot;feet|foot|ft&quot;, &quot;&#39;&quot;) %&gt;% #convert feet symbols to &#39; str_replace_all(&quot;inches|in|&#39;&#39;|\\&quot;|cm|and&quot;, &quot;&quot;) %&gt;% #remove inches and other symbols str_replace(&quot;^([4-7])\\\\s*[,\\\\.\\\\s+]\\\\s*(\\\\d*)$&quot;, &quot;\\\\1&#39;\\\\2&quot;) %&gt;% #change x.y, x,y x y str_replace(&quot;^([56])&#39;?$&quot;, &quot;\\\\1&#39;0&quot;) %&gt;% #add 0 when to 5 or 6 str_replace(&quot;^([12])\\\\s*,\\\\s*(\\\\d*)$&quot;, &quot;\\\\1\\\\.\\\\2&quot;) %&gt;% #change european decimal str_trim() #remove extra space } words_to_numbers &lt;- function(s){ str_to_lower(s) %&gt;% str_replace_all(&quot;zero&quot;, &quot;0&quot;) %&gt;% str_replace_all(&quot;one&quot;, &quot;1&quot;) %&gt;% str_replace_all(&quot;two&quot;, &quot;2&quot;) %&gt;% str_replace_all(&quot;three&quot;, &quot;3&quot;) %&gt;% str_replace_all(&quot;four&quot;, &quot;4&quot;) %&gt;% str_replace_all(&quot;five&quot;, &quot;5&quot;) %&gt;% str_replace_all(&quot;six&quot;, &quot;6&quot;) %&gt;% str_replace_all(&quot;seven&quot;, &quot;7&quot;) %&gt;% str_replace_all(&quot;eight&quot;, &quot;8&quot;) %&gt;% str_replace_all(&quot;nine&quot;, &quot;9&quot;) %&gt;% str_replace_all(&quot;ten&quot;, &quot;10&quot;) %&gt;% str_replace_all(&quot;eleven&quot;, &quot;11&quot;) } smallest &lt;- 50 tallest &lt;- 84 new_heights &lt;- reported_heights %&gt;% mutate(original = height, height = words_to_numbers(height) %&gt;% convert_format()) %&gt;% extract(height, c(&quot;feet&quot;, &quot;inches&quot;), regex = pattern, remove = FALSE) %&gt;% mutate_at(c(&quot;height&quot;, &quot;feet&quot;, &quot;inches&quot;), as.numeric) %&gt;% mutate(guess = 12*feet + inches) %&gt;% mutate(height = case_when( !is.na(height) &amp; between(height, smallest, tallest) ~ height, #inches !is.na(height) &amp; between(height/2.54, smallest, tallest) ~ height/2.54, #centimeters !is.na(height) &amp; between(height*100/2.54, smallest, tallest) ~ height*100/2.54, #meters !is.na(guess) &amp; inches &lt; 12 &amp; between(guess, smallest, tallest) ~ guess, #feet&#39;inches TRUE ~ as.numeric(NA))) %&gt;% select(-guess) ## Warning: Problem with `mutate()` input `height`. ## ℹ NAs introduced by coercion ## ℹ Input `height` is `.Primitive(&quot;as.double&quot;)(height)`. ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion We can check all the entries we converted using the following code: new_heights %&gt;% filter(not_inches(original)) %&gt;% select(original, height) %&gt;% arrange(height) %&gt;% View() # Open XQuartz-app to run this command Let’s take a look at the shortest students in our dataset using the following code: new_heights %&gt;% arrange(height) %&gt;% head(n=7) ## time_stamp sex height feet inches original ## 1 2017-07-04 01:30:25 Male 50.00 NA NA 50 ## 2 2017-09-07 10:40:35 Male 50.00 NA NA 50 ## 3 2014-09-02 15:18:30 Female 51.00 NA NA 51 ## 4 2016-06-05 14:07:20 Female 52.00 NA NA 52 ## 5 2016-06-05 14:07:38 Female 52.00 NA NA 52 ## 6 2014-09-23 03:39:56 Female 53.00 NA NA 53 ## 7 2015-01-07 08:57:29 Male 53.77 NA NA 53.77 We see heights of 53, 54, and 55. In the original heights column, we also have 51 and 52. These short heights are very rare and it is likely that the students actually meant 5’1, 5’2, 5’3, 5’4, and 5’5. But because we are not completely sure, we will leave them as reported. 4.16 String Splitting The textbook for this section is available here. Key Points The function str_split() splits a string into a character vector on a delimiter (such as a comma, space or underscore). By default, str_split() generates a list with one element for each original string. Use the function argument simplify=TRUE to have str_split() return a matrix instead. The map() function from the purrr package applies the same function to each element of a list. To extract the ith entry of each element x, use map(x, i). map() always returns a list. Use map_chr() to return a character vector and map_int() to return an integer. Code # read raw murders data line by line filename &lt;- system.file(&quot;extdata/murders.csv&quot;, package = &quot;dslabs&quot;) lines &lt;- readLines(filename) lines %&gt;% head() ## [1] &quot;state,abb,region,population,total&quot; &quot;Alabama,AL,South,4779736,135&quot; &quot;Alaska,AK,West,710231,19&quot; &quot;Arizona,AZ,West,6392017,232&quot; ## [5] &quot;Arkansas,AR,South,2915918,93&quot; &quot;California,CA,West,37253956,1257&quot; # split at commas with str_split function, remove row of column names x &lt;- str_split(lines, &quot;,&quot;) x %&gt;% head() ## [[1]] ## [1] &quot;state&quot; &quot;abb&quot; &quot;region&quot; &quot;population&quot; &quot;total&quot; ## ## [[2]] ## [1] &quot;Alabama&quot; &quot;AL&quot; &quot;South&quot; &quot;4779736&quot; &quot;135&quot; ## ## [[3]] ## [1] &quot;Alaska&quot; &quot;AK&quot; &quot;West&quot; &quot;710231&quot; &quot;19&quot; ## ## [[4]] ## [1] &quot;Arizona&quot; &quot;AZ&quot; &quot;West&quot; &quot;6392017&quot; &quot;232&quot; ## ## [[5]] ## [1] &quot;Arkansas&quot; &quot;AR&quot; &quot;South&quot; &quot;2915918&quot; &quot;93&quot; ## ## [[6]] ## [1] &quot;California&quot; &quot;CA&quot; &quot;West&quot; &quot;37253956&quot; &quot;1257&quot; col_names &lt;- x[[1]] x &lt;- x[-1] # extract first element of each list entry if(!require(purrr)) install.packages(&quot;purrr&quot;) library(purrr) map(x, function(y) y[1]) %&gt;% head() ## [[1]] ## [1] &quot;Alabama&quot; ## ## [[2]] ## [1] &quot;Alaska&quot; ## ## [[3]] ## [1] &quot;Arizona&quot; ## ## [[4]] ## [1] &quot;Arkansas&quot; ## ## [[5]] ## [1] &quot;California&quot; ## ## [[6]] ## [1] &quot;Colorado&quot; map(x, 1) %&gt;% head() ## [[1]] ## [1] &quot;Alabama&quot; ## ## [[2]] ## [1] &quot;Alaska&quot; ## ## [[3]] ## [1] &quot;Arizona&quot; ## ## [[4]] ## [1] &quot;Arkansas&quot; ## ## [[5]] ## [1] &quot;California&quot; ## ## [[6]] ## [1] &quot;Colorado&quot; # extract columns 1-5 as characters, then convert to proper format - NOTE: DIFFERENT FROM VIDEO dat &lt;- data.frame(parse_guess(map_chr(x, 1)), parse_guess(map_chr(x, 2)), parse_guess(map_chr(x, 3)), parse_guess(map_chr(x, 4)), parse_guess(map_chr(x, 5))) %&gt;% setNames(col_names) dat %&gt;% head ## state abb region population total ## 1 Alabama AL South 4779736 135 ## 2 Alaska AK West 710231 19 ## 3 Arizona AZ West 6392017 232 ## 4 Arkansas AR South 2915918 93 ## 5 California CA West 37253956 1257 ## 6 Colorado CO West 5029196 65 # more efficient code for the same thing dat &lt;- x %&gt;% transpose() %&gt;% map( ~ parse_guess(unlist(.))) %&gt;% setNames(col_names) %&gt;% as.data.frame() # the simplify argument makes str_split return a matrix instead of a list x &lt;- str_split(lines, &quot;,&quot;, simplify = TRUE) col_names &lt;- x[1,] x &lt;- x[-1,] x %&gt;% as_data_frame() %&gt;% setNames(col_names) %&gt;% mutate_all(parse_guess) ## Warning: `as_data_frame()` is deprecated as of tibble 2.0.0. ## Please use `as_tibble()` instead. ## The signature and semantics have changed, see `?as_tibble`. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. ## Using compatibility `.name_repair`. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## # A tibble: 51 x 5 ## state abb region population total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alabama AL South 4779736 135 ## 2 Alaska AK West 710231 19 ## 3 Arizona AZ West 6392017 232 ## 4 Arkansas AR South 2915918 93 ## 5 California CA West 37253956 1257 ## 6 Colorado CO West 5029196 65 ## 7 Connecticut CT Northeast 3574097 97 ## 8 Delaware DE South 897934 38 ## 9 District of Columbia DC South 601723 99 ## 10 Florida FL South 19687653 669 ## # … with 41 more rows 4.17 Case Study - Extracting a Table from a PDF The textbook for this section is available here. One of the datasets provided in dslabs shows scientific funding rates by gender in the Netherlands: data(&quot;research_funding_rates&quot;) research_funding_rates ## discipline applications_total applications_men applications_women awards_total awards_men awards_women success_rates_total success_rates_men success_rates_women ## 1 Chemical sciences 122 83 39 32 22 10 26.2 26.5 25.6 ## 2 Physical sciences 174 135 39 35 26 9 20.1 19.3 23.1 ## 3 Physics 76 67 9 20 18 2 26.3 26.9 22.2 ## 4 Humanities 396 230 166 65 33 32 16.4 14.3 19.3 ## 5 Technical sciences 251 189 62 43 30 13 17.1 15.9 21.0 ## 6 Interdisciplinary 183 105 78 29 12 17 15.8 11.4 21.8 ## 7 Earth/life sciences 282 156 126 56 38 18 19.9 24.4 14.3 ## 8 Social sciences 834 425 409 112 65 47 13.4 15.3 11.5 ## 9 Medical sciences 505 245 260 75 46 29 14.9 18.8 11.2 The data come from a paper published in the prestigious journal PNAS. However, the data are not provided in a spreadsheet; they are in a table in a PDF document. We could extract the numbers by hand, but this could lead to human error. Instead we can try to wrangle the data using R. **Downloading the data* We start by downloading the PDF document then importing it into R using the following code: if(!require(pdftools)) install.packages(&quot;pdftools&quot;) ## Loading required package: pdftools ## Using poppler version 0.73.0 library(&quot;pdftools&quot;) temp_file &lt;- tempfile() url &lt;- &quot;http://www.pnas.org/content/suppl/2015/09/16/1510159112.DCSupplemental/pnas.201510159SI.pdf&quot; download.file(url, temp_file) txt &lt;- pdf_text(temp_file) file.remove(temp_file) ## [1] TRUE If we examine the object txt we notice that it is a character vector with an entry for each page. So we keep the page we want using the following code: raw_data_research_funding_rates &lt;- txt[2] The steps above can actually be skipped because we include the raw data in the dslabs package as well: data(&quot;raw_data_research_funding_rates&quot;) Looking at the download Examining this object, raw_data_research_funding_rates %&gt;% head ## [1] &quot; Table S1. Numbers of applications and awarded grants, along with success rates for male and\\n female applicants, by scientific discipline\\n Applications, n Awards, n Success rates, %\\n Discipline Total Men Women Total Men Women Total Men Women\\n Total 2,823 1,635 1,188 467 290 177 16.5 17.7a 14.9b\\n Chemical sciences 122 83 39 32 22 10 26.2 26.5a 25.6a\\n Physical sciences 174 135 39 35 26 9 20.1 19.3a 23.1a\\n Physics 76 67 9 20 18 2 26.3 26.9a 22.2a\\n Humanities 396 230 166 65 33 32 16.4 14.3a 19.3a\\n Technical sciences 251 189 62 43 30 13 17.1 15.9a 21.0a\\n Interdisciplinary 183 105 78 29 12 17 15.8 11.4a 21.8a\\n Earth/life sciences 282 156 126 56 38 18 19.9 24.4a 14.3b\\n Social sciences 834 425 409 112 65 47 13.4 15.3a 11.5a\\n Medical sciences 505 245 260 75 46 29 14.9 18.8a 11.2b\\n Success rates for male and female applicants with different subscripts differ reliably from one another (P &lt; 0.05).\\n Table S2. Numbers of applications and awarded grants, along with success rates for male and\\n female applicants, by first-time applications vs. reapplications in one call, 2012\\n Applications, n Awards, n Success rates, %\\n Category Total Men Women Total Men Women Total Men Women\\n Total 921 527 394 147 93 54 16.0 17.6i 13.7i\\n First-time applications 722 417 305 100 67 33 13.9i 16.1a 10.8b\\n Reapplications 199 110 89 47 26 21 23.6j 23.6ac 23.6c\\n Success rates for male and female applicants with different subscripts per row and column differ reliably from\\n one another (P &lt; 0.05).\\nvan der Lee and Ellemers www.pnas.org/cgi/content/short/1510159112 2 of 2\\n&quot; we see that it is a long string. Each line on the page, including the table rows, is separated by the symbol for newline: \\n. We can therefore can create a list with the lines of the text as elements: tab &lt;- str_split(raw_data_research_funding_rates, &quot;\\n&quot;) Because we start off with just one element in the string, we end up with a list with just one entry: tab &lt;- tab[[1]] By examining this object, tab %&gt;% head ## [1] &quot; Table S1. Numbers of applications and awarded grants, along with success rates for male and&quot; ## [2] &quot; female applicants, by scientific discipline&quot; ## [3] &quot; Applications, n Awards, n Success rates, %&quot; ## [4] &quot; Discipline Total Men Women Total Men Women Total Men Women&quot; ## [5] &quot; Total 2,823 1,635 1,188 467 290 177 16.5 17.7a 14.9b&quot; ## [6] &quot; Chemical sciences 122 83 39 32 22 10 26.2 26.5a 25.6a&quot; we see that the information for the column names is the third and fourth entires: the_names_1 &lt;- tab[3] the_names_2 &lt;- tab[4] In the table, the column information is spread across two lines. We want to create one vector with one name for each column. We can do this using some of the functions we have just learned. Extracting the table data Let’s start with the first line: the_names_1 ## [1] &quot; Applications, n Awards, n Success rates, %&quot; We want to remove the leading space and everything following the comma. We can use regex for the latter. Then we can obtain the elements by splitting using the space. We want to split only when there are 2 or more spaces to avoid splitting success rate. So we use the regex \\\\s{2,} as follows: the_names_1 &lt;- the_names_1 %&gt;% str_trim() %&gt;% str_replace_all(&quot;,\\\\s.&quot;, &quot;&quot;) %&gt;% str_split(&quot;\\\\s{2,}&quot;, simplify = TRUE) the_names_1 ## [,1] [,2] [,3] ## [1,] &quot;Applications&quot; &quot;Awards&quot; &quot;Success rates&quot; Now let’s look at the second line: the_names_2 ## [1] &quot; Discipline Total Men Women Total Men Women Total Men Women&quot; Here we want to trim the leading space and then split by space as we did for the first line: the_names_2 &lt;- the_names_2 %&gt;% str_trim() %&gt;% str_split(&quot;\\\\s+&quot;, simplify = TRUE) the_names_2 ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] &quot;Discipline&quot; &quot;Total&quot; &quot;Men&quot; &quot;Women&quot; &quot;Total&quot; &quot;Men&quot; &quot;Women&quot; &quot;Total&quot; &quot;Men&quot; &quot;Women&quot; Now we can join these to generate one name for each column: tmp_names &lt;- str_c(rep(the_names_1, each = 3), the_names_2[-1], sep = &quot;_&quot;) the_names &lt;- c(the_names_2[1], tmp_names) %&gt;% str_to_lower() %&gt;% str_replace_all(&quot;\\\\s&quot;, &quot;_&quot;) the_names ## [1] &quot;discipline&quot; &quot;applications_total&quot; &quot;applications_men&quot; &quot;applications_women&quot; &quot;awards_total&quot; &quot;awards_men&quot; &quot;awards_women&quot; &quot;success_rates_total&quot; ## [9] &quot;success_rates_men&quot; &quot;success_rates_women&quot; Now we are ready to get the actual data. By examining the tab object, we notice that the information is in lines 6 through 14. We can use str_split() again to achieve our goal: new_research_funding_rates &lt;- tab[6:14] %&gt;% str_trim %&gt;% str_split(&quot;\\\\s{2,}&quot;, simplify = TRUE) %&gt;% data.frame(stringsAsFactors = FALSE) %&gt;% setNames(the_names) %&gt;% mutate_at(-1, parse_number) new_research_funding_rates %&gt;% head() ## discipline applications_total applications_men applications_women awards_total awards_men awards_women success_rates_total success_rates_men success_rates_women ## 1 Chemical sciences 122 83 39 32 22 10 26.2 26.5 25.6 ## 2 Physical sciences 174 135 39 35 26 9 20.1 19.3 23.1 ## 3 Physics 76 67 9 20 18 2 26.3 26.9 22.2 ## 4 Humanities 396 230 166 65 33 32 16.4 14.3 19.3 ## 5 Technical sciences 251 189 62 43 30 13 17.1 15.9 21.0 ## 6 Interdisciplinary 183 105 78 29 12 17 15.8 11.4 21.8 We can see that the objects are identical: identical(research_funding_rates, new_research_funding_rates) ## [1] TRUE 4.18 Recoding The textbook for this section is available here. Key points Change long factor names with the recode() function from the tidyverse. Other similar functions include recode_factor() and fct_recoder() in the forcats package in the tidyverse. The same result could be obtained using the case_when() function, but recode() is more efficient to write. Code # life expectancy time series for Caribbean countries gapminder %&gt;% filter(region==&quot;Caribbean&quot;) %&gt;% ggplot(aes(year, life_expectancy, color = country)) + geom_line() # display long country names gapminder %&gt;% filter(region==&quot;Caribbean&quot;) %&gt;% filter(str_length(country) &gt;= 12) %&gt;% distinct(country) ## country ## 1 Antigua and Barbuda ## 2 Dominican Republic ## 3 St. Vincent and the Grenadines ## 4 Trinidad and Tobago # recode long country names and remake plot gapminder %&gt;% filter(region==&quot;Caribbean&quot;) %&gt;% mutate(country = recode(country, &#39;Antigua and Barbuda&#39;=&quot;Barbuda&quot;, &#39;Dominican Republic&#39; = &quot;DR&quot;, &#39;St. Vincent and the Grenadines&#39; = &quot;St. Vincent&quot;, &#39;Trinidad and Tobago&#39; = &quot;Trinidad&quot;)) %&gt;% ggplot(aes(year, life_expectancy, color = country)) + geom_line() 4.19 Assessment - String Processing Part 3 Want even more practice with regular expressions? Complete the lessons and exercises in the RegexOne online interactive tutorial! s &lt;- c(&quot;5&#39;10&quot;, &quot;6&#39;1\\&quot;&quot;, &quot;5&#39;8inches&quot;, &quot;5&#39;7.5&quot;) tab &lt;- data.frame(x = s) If you use the extract code from our video, the decimal point is dropped. What modification of the code would allow you to put the decimals in a third column called “decimal”? extract(data = tab, col = x, into = c(&quot;feet&quot;, &quot;inches&quot;, &quot;decimal&quot;), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})(\\\\.\\\\d+)?&quot;) ## feet inches decimal ## 1 5 10 ## 2 6 1 ## 3 5 8 ## 4 5 7 .5 A. extract(data = tab, col = x, into = c(“feet”, “inches”, “decimal”), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})(\\\\.)?&quot; B. extract(data = tab, col = x, into = c(&quot;feet&quot;, &quot;inches&quot;, &quot;decimal&quot;), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})(\\\\.\\\\d+)&quot; C. extract(data = tab, col = x, into = c(&quot;feet&quot;, &quot;inches&quot;, &quot;decimal&quot;), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})\\\\.\\\\d+?&quot; D. extract(data = tab, col = x, into = c(&quot;feet&quot;, &quot;inches&quot;, &quot;decimal&quot;), regex = &quot;(\\\\d)&#39;(\\\\d{1,2})(\\\\.\\\\d+)?&quot;) You have the following table, schedule &gt;schedule day staff Monday Mandy, Chris and Laura Tuesday Steve, Ruth and Frank You want to turn this into a more useful data frame. Which two commands would properly split the text in the “staff” column into each individual name? Select ALL that apply. A. str_split(schedule$staff, \",|and\") B. str_split(schedule$staff, \", | and \") C. str_split(schedule$staff, \",\\\\s|\\\\sand\\\\s\") D. str_split(schedule$staff, \"\\\\s?(,|and)\\\\s?\") You have the following table, schedule &gt; schedule day staff Monday Mandy, Chris and Laura Tuesday Steve, Ruth and Frank What code would successfully turn your “Schedule” table into the following tidy table &lt; tidy day staff &lt;chr&gt; &lt;chr&gt; Monday Mandy Monday Chris Monday Laura Tuesday Steve Tuesday Ruth Tuesday Frank A. tidy &lt;- schedule %&gt;% mutate(staff = str_split(staff, &quot;, | and &quot;)) %&gt;% unnest() B. tidy &lt;- separate(schedule, staff, into = c(&quot;s1&quot;,&quot;s2&quot;,&quot;s3&quot;), sep = “,”) %&gt;% gather(key = s, value = staff, s1:s3) C. tidy &lt;- schedule %&gt;% mutate(staff = str_split(staff, &quot;, | and &quot;, simplify = TRUE)) %&gt;% unnest() Using the gapminder data, you want to recode countries longer than 12 letters in the region “Middle Africa” to their abbreviations in a new column, “country_short”. Which code would accomplish this? dat &lt;- gapminder %&gt;% filter(region == &quot;Middle Africa&quot;) %&gt;% mutate(country_short = recode(country, &quot;Central African Republic&quot; = &quot;CAR&quot;, &quot;Congo, Dem. Rep.&quot; = &quot;DRC&quot;, &quot;Equatorial Guinea&quot; = &quot;Eq. Guinea&quot;)) dat ## country year infant_mortality life_expectancy fertility population gdp continent region country_short ## 1 Angola 1960 208.0 35.98 7.32 5270844 NA Africa Middle Africa Angola ## 2 Cameroon 1960 166.9 43.46 5.65 5361367 2537944080 Africa Middle Africa Cameroon ## 3 Central African Republic 1960 165.5 37.43 5.84 1503501 534982718 Africa Middle Africa CAR ## 4 Chad 1960 NA 40.95 6.25 3002596 750173439 Africa Middle Africa Chad ## 5 Congo, Dem. Rep. 1960 174.0 43.90 6.00 15248246 4992962083 Africa Middle Africa DRC ## 6 Congo, Rep. 1960 110.6 48.25 5.88 1013581 626127041 Africa Middle Africa Congo, Rep. ## 7 Equatorial Guinea 1960 NA 37.69 5.51 252115 NA Africa Middle Africa Eq. Guinea ## 8 Gabon 1960 NA 38.83 4.38 499189 887289809 Africa Middle Africa Gabon ## 9 Angola 1961 NA 36.53 7.35 5367287 NA Africa Middle Africa Angola ## 10 Cameroon 1961 163.3 44.00 5.71 5474509 2785779139 Africa Middle Africa Cameroon ## 11 Central African Republic 1961 162.9 37.89 5.87 1529229 561479896 Africa Middle Africa CAR ## 12 Chad 1961 NA 41.35 6.27 3061423 760658941 Africa Middle Africa Chad ## 13 Congo, Dem. Rep. 1961 NA 44.25 6.02 15637715 4451156989 Africa Middle Africa DRC ## 14 Congo, Rep. 1961 108.4 48.88 5.92 1039966 678538008 Africa Middle Africa Congo, Rep. ## 15 Equatorial Guinea 1961 NA 38.04 5.52 255100 NA Africa Middle Africa Eq. Guinea ## 16 Gabon 1961 NA 39.15 4.46 504174 1018309175 Africa Middle Africa Gabon ## 17 Angola 1962 NA 37.08 7.39 5465905 NA Africa Middle Africa Angola ## 18 Cameroon 1962 160.5 44.53 5.77 5593768 2870510257 Africa Middle Africa Cameroon ## 19 Central African Republic 1962 160.4 38.36 5.89 1556656 540628554 Africa Middle Africa CAR ## 20 Chad 1962 NA 41.76 6.29 3122357 801431143 Africa Middle Africa Chad ## 21 Congo, Dem. Rep. 1962 NA 44.61 6.03 16041247 5394833319 Africa Middle Africa DRC ## 22 Congo, Rep. 1962 106.1 49.47 5.97 1067611 713837650 Africa Middle Africa Congo, Rep. ## 23 Equatorial Guinea 1962 NA 38.38 5.53 257940 NA Africa Middle Africa Eq. Guinea ## 24 Gabon 1962 NA 39.56 4.54 509806 1094165180 Africa Middle Africa Gabon ## 25 Angola 1963 NA 37.63 7.41 5565808 NA Africa Middle Africa Angola ## 26 Cameroon 1963 158.1 45.07 5.83 5719135 2977940547 Africa Middle Africa Cameroon ## 27 Central African Republic 1963 157.6 38.85 5.91 1585765 536804991 Africa Middle Africa CAR ## 28 Chad 1963 NA 42.17 6.30 3184775 788612621 Africa Middle Africa Chad ## 29 Congo, Dem. Rep. 1963 NA 44.98 6.05 16461914 5676119396 Africa Middle Africa DRC ## 30 Congo, Rep. 1963 104.2 50.04 6.01 1096502 685074987 Africa Middle Africa Congo, Rep. ## 31 Equatorial Guinea 1963 NA 38.73 5.55 260990 NA Africa Middle Africa Eq. Guinea ## 32 Gabon 1963 NA 40.07 4.62 516270 1160826485 Africa Middle Africa Gabon ## 33 Angola 1964 NA 38.18 7.43 5665701 NA Africa Middle Africa Angola ## 34 Cameroon 1964 155.5 45.59 5.89 5850454 3083572854 Africa Middle Africa Cameroon ## 35 Central African Republic 1964 154.7 39.36 5.93 1616515 547972474 Africa Middle Africa CAR ## 36 Chad 1964 NA 42.58 6.32 3247798 768811034 Africa Middle Africa Chad ## 37 Congo, Dem. Rep. 1964 NA 45.36 6.07 16903899 5537609393 Africa Middle Africa DRC ## 38 Congo, Rep. 1964 102.1 50.55 6.06 1126602 711222903 Africa Middle Africa Congo, Rep. ## 39 Equatorial Guinea 1964 NA 39.08 5.57 264743 NA Africa Middle Africa Eq. Guinea ## 40 Gabon 1964 NA 40.70 4.69 523793 1213695790 Africa Middle Africa Gabon ## 41 Angola 1965 NA 38.74 7.43 5765025 NA Africa Middle Africa Angola ## 42 Cameroon 1965 152.2 46.13 5.95 5987671 3146047697 Africa Middle Africa Cameroon ## 43 Central African Republic 1965 151.7 39.92 5.94 1648830 553164891 Africa Middle Africa CAR ## 44 Chad 1965 NA 43.01 6.34 3310921 773471780 Africa Middle Africa Chad ## 45 Congo, Dem. Rep. 1965 NA 45.77 6.09 17369859 5592838673 Africa Middle Africa DRC ## 46 Congo, Rep. 1965 99.7 51.02 6.10 1157905 737370784 Africa Middle Africa Congo, Rep. ## 47 Equatorial Guinea 1965 NA 39.44 5.60 269427 NA Africa Middle Africa Eq. Guinea ## 48 Gabon 1965 NA 41.42 4.77 532512 1314837134 Africa Middle Africa Gabon ## 49 Angola 1966 NA 39.28 7.42 5863568 NA Africa Middle Africa Angola ## 50 Cameroon 1966 148.1 46.67 6.01 6130990 3291236402 Africa Middle Africa Cameroon ## 51 Central African Republic 1966 148.6 40.50 5.95 1682874 556732800 Africa Middle Africa CAR ## 52 Chad 1966 NA 43.48 6.36 3373563 759494431 Africa Middle Africa Chad ## 53 Congo, Dem. Rep. 1966 NA 46.20 6.11 17861860 5971780635 Africa Middle Africa DRC ## 54 Congo, Rep. 1966 97.3 51.45 6.14 1190361 747391524 Africa Middle Africa Congo, Rep. ## 55 Equatorial Guinea 1966 NA 39.78 5.62 275470 NA Africa Middle Africa Eq. Guinea ## 56 Gabon 1966 NA 42.21 4.83 542562 1374110052 Africa Middle Africa Gabon ## 57 Angola 1967 NA 39.84 7.40 5962831 NA Africa Middle Africa Angola ## 58 Cameroon 1967 143.1 47.22 6.06 6280743 2932094527 Africa Middle Africa Cameroon ## 59 Central African Republic 1967 145.6 41.15 5.95 1718558 582768491 Africa Middle Africa CAR ## 60 Chad 1967 NA 43.98 6.39 3436227 765321282 Africa Middle Africa Chad ## 61 Congo, Dem. Rep. 1967 NA 46.66 6.14 18378189 5912914485 Africa Middle Africa DRC ## 62 Congo, Rep. 1967 94.9 51.84 6.17 1224041 763208362 Africa Middle Africa Congo, Rep. ## 63 Equatorial Guinea 1967 NA 40.13 5.64 282445 NA Africa Middle Africa Eq. Guinea ## 64 Gabon 1967 NA 43.06 4.90 553829 1430656781 Africa Middle Africa Gabon ## 65 Angola 1968 NA 40.39 7.38 6066094 NA Africa Middle Africa Angola ## 66 Cameroon 1968 137.3 47.79 6.11 6437157 3118174741 Africa Middle Africa Cameroon ## 67 Central African Republic 1968 142.6 41.84 5.95 1755260 590951707 Africa Middle Africa CAR ## 68 Chad 1968 NA 44.54 6.43 3500778 761822089 Africa Middle Africa Chad ## 69 Congo, Dem. Rep. 1968 NA 47.14 6.16 18913177 6169103240 Africa Middle Africa DRC ## 70 Congo, Rep. 1968 92.7 52.21 6.21 1259190 821451282 Africa Middle Africa Congo, Rep. ## 71 Equatorial Guinea 1968 NA 40.48 5.66 288701 NA Africa Middle Africa Eq. Guinea ## 72 Gabon 1968 NA 43.90 4.96 565878 1466549111 Africa Middle Africa Gabon ## 73 Angola 1969 NA 40.95 7.34 6177703 NA Africa Middle Africa Angola ## 74 Cameroon 1969 131.5 48.37 6.16 6600479 3271011438 Africa Middle Africa Cameroon ## 75 Central African Republic 1969 139.8 42.57 5.95 1792150 632858495 Africa Middle Africa CAR ## 76 Chad 1969 137.3 45.12 6.48 3569778 814245430 Africa Middle Africa Chad ## 77 Congo, Dem. Rep. 1969 150.7 47.63 6.19 19458874 6744608852 Africa Middle Africa DRC ## 78 Congo, Rep. 1969 90.6 52.54 6.24 1296137 883458739 Africa Middle Africa Congo, Rep. ## 79 Equatorial Guinea 1969 NA 40.82 5.67 292014 NA Africa Middle Africa Eq. Guinea ## 80 Gabon 1969 NA 44.74 5.02 578114 1585088962 Africa Middle Africa Gabon ## 81 Angola 1970 180.0 41.50 7.30 6300969 NA Africa Middle Africa Angola ## 82 Cameroon 1970 126.2 48.97 6.21 6770967 3372153343 Africa Middle Africa Cameroon ## 83 Central African Republic 1970 137.0 43.36 5.95 1828710 647622869 Africa Middle Africa CAR ## 84 Chad 1970 135.9 45.72 6.53 3644911 829387598 Africa Middle Africa Chad ## 85 Congo, Dem. Rep. 1970 149.0 48.13 6.21 20009902 6728080745 Africa Middle Africa DRC ## 86 Congo, Rep. 1970 88.5 52.85 6.26 1335090 939633199 Africa Middle Africa Congo, Rep. ## 87 Equatorial Guinea 1970 NA 41.17 5.68 290905 NA Africa Middle Africa Eq. Guinea ## 88 Gabon 1970 NA 45.55 5.08 590119 1722664256 Africa Middle Africa Gabon ## 89 Angola 1971 NA 42.06 7.26 6437645 NA Africa Middle Africa Angola ## 90 Cameroon 1971 121.6 49.59 6.25 6948847 3489494427 Africa Middle Africa Cameroon ## 91 Central African Republic 1971 134.5 44.19 5.95 1864757 654941830 Africa Middle Africa CAR ## 92 Chad 1971 134.5 46.33 6.58 3727382 810746064 Africa Middle Africa Chad ## 93 Congo, Dem. Rep. 1971 147.5 48.60 6.24 20563111 7132103209 Africa Middle Africa DRC ## 94 Congo, Rep. 1971 86.5 53.14 6.28 1376189 1012483298 Africa Middle Africa Congo, Rep. ## 95 Equatorial Guinea 1971 NA 41.52 5.68 284915 NA Africa Middle Africa Eq. Guinea ## 96 Gabon 1971 NA 46.35 5.14 601734 1899387747 Africa Middle Africa Gabon ## 97 Angola 1972 NA 42.62 7.23 6587647 NA Africa Middle Africa Angola ## 98 Cameroon 1972 118.2 50.22 6.29 7134374 3582798039 Africa Middle Africa Cameroon ## 99 Central African Republic 1972 132.1 45.04 5.95 1900702 654936703 Africa Middle Africa CAR ## 100 Chad 1972 131.8 46.91 6.64 3816299 820066531 Africa Middle Africa Chad ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 356 rows ] A. dat &lt;- gapminder %&gt;% filter(region == &quot;Middle Africa&quot;) %&gt;% mutate(recode(country, &quot;Central African Republic&quot; = &quot;CAR&quot;, &quot;Congo, Dem. Rep.&quot; = &quot;DRC&quot;, &quot;Equatorial Guinea&quot; = &quot;Eq. Guinea&quot;)) B. dat &lt;- gapminder %&gt;% filter(region == &quot;Middle Africa&quot;) %&gt;% mutate(country_short = recode(country, c(&quot;Central African Republic&quot;, &quot;Congo, Dem. Rep.&quot;, &quot;Equatorial Guinea&quot;), c(&quot;CAR&quot;, &quot;DRC&quot;, &quot;Eq. Guinea&quot;))) C. dat &lt;- gapminder %&gt;% filter(region == &quot;Middle Africa&quot;) %&gt;% mutate(country = recode(country, &quot;Central African Republic&quot; = &quot;CAR&quot;, &quot;Congo, Dem. Rep.&quot; = &quot;DRC&quot;, &quot;Equatorial Guinea&quot; = &quot;Eq. Guinea&quot;)) D. dat &lt;- gapminder %&gt;% filter(region == &quot;Middle Africa&quot;) %&gt;% mutate(country_short = recode(country, &quot;Central African Republic&quot; = &quot;CAR&quot;, &quot;Congo, Dem. Rep.&quot; = &quot;DRC&quot;, &quot;Equatorial Guinea&quot; = &quot;Eq. Guinea&quot;)) Import raw Brexit referendum polling data from Wikipedia: if(!require(stringr)) install.packages(&quot;stringr&quot;) library(stringr) url &lt;- &quot;https://en.wikipedia.org/w/index.php?title=Opinion_polling_for_the_United_Kingdom_European_Union_membership_referendum&amp;oldid=896735054&quot; tab &lt;- read_html(url) %&gt;% html_nodes(&quot;table&quot;) polls &lt;- tab[[5]] %&gt;% html_table(fill = TRUE) You will use a variety of string processing techniques learned in this section to reformat these data. Some rows in this table do not contain polls. You can identify these by the lack of the percent sign (%) in the Remain column. Update polls by changing the column names to c(\"dates\", \"remain\", \"leave\", \"undecided\", \"lead\", \"samplesize\", \"pollster\", \"poll_type\", \"notes\") and only keeping rows that have a percent sign (%) in the remain column. How many rows remain in the polls data frame? names(polls) &lt;- c(&quot;dates&quot;, &quot;remain&quot;, &quot;leave&quot;, &quot;undecided&quot;, &quot;lead&quot;, &quot;samplesize&quot;, &quot;pollster&quot;, &quot;poll_type&quot;, &quot;notes&quot;) polls &lt;- polls[str_detect(polls$remain, &quot;%&quot;), -9] nrow(polls) ## [1] 129 The remain and leave columns are both given in the format “48.1%”: percentages out of 100% with a percent symbol. Which of these commands converts the remain vector to a proportion between 0 and 1? Check all correct answers. A. as.numeric(str_remove(polls$remain, \"%\")) B. as.numeric(polls$remain)/100 C. parse_number(polls$remain) D. str_remove(polls$remain, \"%\")/100 E. as.numeric(str_replace(polls$remain, \"%\", \"\"))/100 F. parse_number(polls$remain)/100 The undecided column has some “N/A” values. These “N/A”s are only present when the remain and leave columns total 100%, so they should actually be zeros. Use a function from stringr to convert “N/A” in the undecided column to 0. The format of your command should be function_name(polls$undecided, \"arg1\", \"arg2\"). What function replaces function_name? str_replace What argument replaces arg1? N/A What argument replaces arg2? 0 The dates column contains the range of dates over which the poll was conducted. The format is “8-10 Jan” where the poll had a start date of 2016-01-08 and end date of 2016-01-10. Some polls go across month boundaries (16 May-12 June). The end date of the poll will always be one or two digits, followed by a space, followed by the month as one or more letters (either capital or lowercase). In these data, all month abbreviations or names have 3, 4 or 5 letters. Write a regular expression to extract the end day and month from dates. Insert it into the skeleton code below: temp &lt;- str_extract_all(polls$dates, _____) end_date &lt;- sapply(temp, function(x) x[length(x)]) # take last element (handles polls that cross month boundaries) Which of the following regular expressions correctly extracts the end day and month when inserted into the blank in the code above? Check all correct answers. A. \"\\\\d?\\\\s[a-zA-Z]?\" B. \"\\\\d+\\\\s[a-zA-Z]+\" C. \"\\\\d+\\\\s[A-Z]+\" D. \"[0-9]+\\\\s[a-zA-Z]+\" E. \"\\\\d{1,2}\\\\s[a-zA-Z]+\" F. \"\\\\d{1,2}[a-zA-Z]+\" G. \"\\\\d+\\\\s[a-zA-Z]{3,5}\" "],
["section-4-overview.html", "5 Section 4 Overview 5.1 Dates and Times 5.2 Text mining 5.3 Assessment Part 1 - Dates, Times, and Text Mining 5.4 Assessment Part 2 - Dates, Times, and Text Mining 5.5 Final: Comprehensive Assessment", " 5 Section 4 Overview In the Dates, Times, and Text Mining section, you will learn how to deal with dates and times in R and also how to generate numerical summaries from text data. After completing this section, you will be able to: Handle dates and times in R. Use the lubridate package to parse dates and times in different formats. Generate numerical summaries from text data and apply data visualization and analysis techniques to those data. 5.1 Dates and Times The textbook for this section is available here. Key points Dates are a separate data type in R.The tidyverse includes functionality for dealing with dates through the lubridate package. Extract the year, month and day from a date object with the year(), month() and day() functions. Parsers convert strings into dates with the standard YYYY-MM-DD format (ISO 8601 format). Use the parser with the name corresponding to the string format of year, month and day (ymd(), ydm(), myd(), mdy(), dmy(), dym()). Get the current time with the Sys.time() function. Use the now() function instead to specify a time zone. You can extract values from time objects with the hour(), minute() and second() functions. Parsers convert strings into times (for example, hms()). Parsers can also create combined date-time objects (for example, mdy_hms()). Code # inspect the startdate column of 2016 polls data, a Date type data(&quot;polls_us_election_2016&quot;) polls_us_election_2016$startdate %&gt;% head ## [1] &quot;2016-11-03&quot; &quot;2016-11-01&quot; &quot;2016-11-02&quot; &quot;2016-11-04&quot; &quot;2016-11-03&quot; &quot;2016-11-03&quot; class(polls_us_election_2016$startdate) ## [1] &quot;Date&quot; as.numeric(polls_us_election_2016$startdate) %&gt;% head ## [1] 17108 17106 17107 17109 17108 17108 # ggplot is aware of dates polls_us_election_2016 %&gt;% filter(pollster == &quot;Ipsos&quot; &amp; state ==&quot;U.S.&quot;) %&gt;% ggplot(aes(startdate, rawpoll_trump)) + geom_line() # lubridate: the tidyverse date package if(!require(lubridate)) install.packages(&quot;lubridate&quot;) ## Loading required package: lubridate ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union library(lubridate) # select some random dates from polls set.seed(2) dates &lt;- sample(polls_us_election_2016$startdate, 10) %&gt;% sort dates ## [1] &quot;2016-01-19&quot; &quot;2016-08-06&quot; &quot;2016-08-26&quot; &quot;2016-09-09&quot; &quot;2016-09-14&quot; &quot;2016-09-16&quot; &quot;2016-09-29&quot; &quot;2016-10-04&quot; &quot;2016-10-12&quot; &quot;2016-10-23&quot; # extract month, day, year from date strings data.frame(date = dates, month = month(dates), day = day(dates), year = year(dates)) ## date month day year ## 1 2016-01-19 1 19 2016 ## 2 2016-08-06 8 6 2016 ## 3 2016-08-26 8 26 2016 ## 4 2016-09-09 9 9 2016 ## 5 2016-09-14 9 14 2016 ## 6 2016-09-16 9 16 2016 ## 7 2016-09-29 9 29 2016 ## 8 2016-10-04 10 4 2016 ## 9 2016-10-12 10 12 2016 ## 10 2016-10-23 10 23 2016 month(dates, label = TRUE) # extract month label ## [1] jan aug aug sep sep sep sep okt okt okt ## Levels: jan &lt; feb &lt; mrt &lt; apr &lt; mei &lt; jun &lt; jul &lt; aug &lt; sep &lt; okt &lt; nov &lt; dec # ymd works on mixed date styles x &lt;- c(20090101, &quot;2009-01-02&quot;, &quot;2009 01 03&quot;, &quot;2009-1-4&quot;, &quot;2009-1, 5&quot;, &quot;Created on 2009 1 6&quot;, &quot;200901 !!! 07&quot;) ymd(x) ## [1] &quot;2009-01-01&quot; &quot;2009-01-02&quot; &quot;2009-01-03&quot; &quot;2009-01-04&quot; &quot;2009-01-05&quot; &quot;2009-01-06&quot; &quot;2009-01-07&quot; # different parsers extract year, month and day in different orders x &lt;- &quot;09/01/02&quot; ymd(x) ## [1] &quot;2009-01-02&quot; mdy(x) ## [1] &quot;2002-09-01&quot; ydm(x) ## [1] &quot;2009-02-01&quot; myd(x) ## [1] &quot;2001-09-02&quot; dmy(x) ## [1] &quot;2002-01-09&quot; dym(x) ## [1] &quot;2001-02-09&quot; now() # current time in your time zone ## [1] &quot;2020-09-11 17:38:02 CEST&quot; now(&quot;GMT&quot;) # current time in GMT ## [1] &quot;2020-09-11 15:38:02 GMT&quot; now() %&gt;% hour() # current hour ## [1] 17 now() %&gt;% minute() # current minute ## [1] 38 now() %&gt;% second() # current second ## [1] 2.700909 # parse time x &lt;- c(&quot;12:34:56&quot;) hms(x) ## [1] &quot;12H 34M 56S&quot; #parse datetime x &lt;- &quot;Nov/2/2012 12:34:56&quot; mdy_hms(x) ## [1] &quot;2012-11-02 12:34:56 UTC&quot; 5.2 Text mining The textbook for this section is available here. Key points The tidytext package helps us convert free form text into a tidy table. Use unnest_tokens() to extract individual words and other meaningful chunks of text. Sentiment analysis assigns emotions or a positive/negative score to tokens. You can extract sentiments using get_sentiments(). Common lexicons for sentiment analysis are “bing”, “afinn”, “nrc” and “loughran”. With the exception of labels used to represent categorical data, we have focused on numerical data, but in many applications data starts as text. Well known examples are spam filtering, cyber-crime prevention, counter-terrorism and sentiment analysis. In all these examples, the raw data is composed of free form texts. Our task is to extract insights from these data. In this section, we learn how to generate useful numerical summaries from text data to which we can apply some of the powerful data visualization and analysis techniques we have learned. Case study: Trump Tweets See my GitHub-repository on Trump Tweets. 5.3 Assessment Part 1 - Dates, Times, and Text Mining options(digits = 3) # 3 significant digits Which of the following is the standard ISO 8601 format for dates? A. MM-DD-YY B. YYYY-MM-DD C. YYYYMMDD D. YY-MM-DD Which of the following commands could convert this string into the correct date format? dates &lt;- c(&quot;09-01-02&quot;, &quot;01-12-07&quot;, &quot;02-03-04&quot;) A. ymd(dates) B. mdy(dates) C. dmy(dates) D. It is impossible to know which format is correct without additional information. Load the brexit_polls data frame from dslabs: data(brexit_polls) How many polls had a start date (startdate) in April (month number 4)? sum(month(brexit_polls$startdate) == 4) ## [1] 25 Use the round_date() function on the enddate column with the argument unit=\"week\". How many polls ended the week of 2016-06-12? Read the documentation to learn more about round_date(). sum(round_date(brexit_polls$enddate, unit = &quot;week&quot;) == &quot;2016-06-12&quot;) ## [1] 13 Use the weekdays() function from lubridate to determine the weekday on which each poll ended (enddate). On which weekday did the greatest number of polls end? table(weekdays(brexit_polls$enddate)) ## ## dinsdag donderdag maandag vrijdag woensdag zaterdag zondag ## 23 17 20 14 12 4 37 A. Monday B. Tuesday C. Wednesday D. Thursday E. Friday F. Saturday G. Sunday max(weekdays(brexit_polls$enddate)) ## [1] &quot;zondag&quot; Load the movielens data frame from dslabs. data(movielens) This data frame contains a set of about 100,000 movie reviews. The timestamp column contains the review date as the number of seconds since 1970-01-01 (epoch time). Convert the timestamp column to dates using the lubridate as_datetime() function. Which year had the most movie reviews? dates &lt;- as_datetime(movielens$timestamp) reviews_by_year &lt;- table(year(dates)) names(which.max(reviews_by_year)) ## [1] &quot;2000&quot; Which hour of the day had the most movie reviews? reviews_by_hour &lt;- table(hour(dates)) names(which.max(reviews_by_hour)) ## [1] &quot;20&quot; 5.4 Assessment Part 2 - Dates, Times, and Text Mining Project Gutenberg is a digital archive of public domain books. The R package gutenbergr facilitates the importation of these texts into R. We will combine this with the tidyverse and tidytext libraries to practice text mining. Use these libraries and options: if(!require(gutenbergr)) install.packages(&quot;gutenbergr&quot;) ## Loading required package: gutenbergr if(!require(tidytext)) install.packages(&quot;tidytext&quot;) ## Loading required package: tidytext library(gutenbergr) library(tidytext) You can see the books and documents available in gutenbergr like this: gutenberg_metadata ## # A tibble: 51,997 x 8 ## gutenberg_id title author gutenberg_author_… language gutenberg_bookshelf rights has_text ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 &lt;NA&gt; &lt;NA&gt; NA en &lt;NA&gt; Public domain… TRUE ## 2 1 &quot;The Declaration of Independence of the United States… Jefferson, Thomas 1638 en United States Law/American Revolutiona… Public domain… TRUE ## 3 2 &quot;The United States Bill of Rights\\r\\nThe Ten Original… United States 1 en American Revolutionary War/Politics/Un… Public domain… TRUE ## 4 3 &quot;John F. Kennedy&#39;s Inaugural Address&quot; Kennedy, John F. (… 1666 en &lt;NA&gt; Public domain… TRUE ## 5 4 &quot;Lincoln&#39;s Gettysburg Address\\r\\nGiven November 19, 1… Lincoln, Abraham 3 en US Civil War Public domain… TRUE ## 6 5 &quot;The United States Constitution&quot; United States 1 en American Revolutionary War/Politics/Un… Public domain… TRUE ## 7 6 &quot;Give Me Liberty or Give Me Death&quot; Henry, Patrick 4 en American Revolutionary War Public domain… TRUE ## 8 7 &quot;The Mayflower Compact&quot; &lt;NA&gt; NA en &lt;NA&gt; Public domain… TRUE ## 9 8 &quot;Abraham Lincoln&#39;s Second Inaugural Address&quot; Lincoln, Abraham 3 en US Civil War Public domain… TRUE ## 10 9 &quot;Abraham Lincoln&#39;s First Inaugural Address&quot; Lincoln, Abraham 3 en US Civil War Public domain… TRUE ## # … with 51,987 more rows Use str_detect() to find the ID of the novel Pride and Prejudice. How many different ID numbers are returned? gutenberg_metadata %&gt;% filter(str_detect(title, &quot;Pride and Prejudice&quot;)) ## # A tibble: 6 x 8 ## gutenberg_id title author gutenberg_author_id language gutenberg_bookshelf rights has_text ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1342 Pride and Prejudice Austen, Jane 68 en Best Books Ever Listings/Harvard Clas… Public domain in the U… TRUE ## 2 20686 Pride and Prejudice Austen, Jane 68 en Harvard Classics/Best Books Ever List… Public domain in the U… FALSE ## 3 20687 Pride and Prejudice Austen, Jane 68 en Harvard Classics/Best Books Ever List… Public domain in the U… FALSE ## 4 26301 Pride and Prejudice Austen, Jane 68 en Best Books Ever Listings Public domain in the U… FALSE ## 5 37431 Pride and Prejudice, a play founded on Jane Austen&#39;s… &lt;NA&gt; NA en &lt;NA&gt; Public domain in the U… TRUE ## 6 42671 Pride and Prejudice Austen, Jane 68 en Best Books Ever Listings Public domain in the U… TRUE Notice that there are several versions of the book. The gutenberg_works() function filters this table to remove replicates and include only English language works. Use this function to find the ID for Pride and Prejudice. What is the correct ID number? Read the gutenberg_works() documentation to learn how to use the function. gutenberg_works(title == &quot;Pride and Prejudice&quot;)$gutenberg_id ## Warning: `filter_()` is deprecated as of dplyr 0.7.0. ## Please use `filter()` instead. ## See vignette(&#39;programming&#39;) for more help ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## Warning: `distinct_()` is deprecated as of dplyr 0.7.0. ## Please use `distinct()` instead. ## See vignette(&#39;programming&#39;) for more help ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## [1] 1342 Use the gutenberg_download() function to download the text for Pride and Prejudice. Use the tidytext package to create a tidy table with all the words in the text. Save this object as `words. How many words are present in the book? book &lt;- gutenberg_download(1342) ## Determining mirror for Project Gutenberg from http://www.gutenberg.org/robot/harvest ## Using mirror http://aleph.gutenberg.org words &lt;- book %&gt;% unnest_tokens(word, text) nrow(words) ## [1] 122204 Remove stop words from the words object. Recall that stop words are defined in the stop_words data frame from the tidytext package. How many words remain? words &lt;- words %&gt;% anti_join(stop_words) ## Joining, by = &quot;word&quot; nrow(words) ## [1] 37246 After removing stop words, detect and then filter out any token that contains a digit from `words. How many words remain? words &lt;- words %&gt;% filter(!str_detect(word, &quot;\\\\d&quot;)) nrow(words) ## [1] 37180 Analyze the most frequent words in the novel after removing stop words and tokens with digits. How many words appear more than 100 times in the book? words %&gt;% count(word) %&gt;% filter(n &gt; 100) %&gt;% nrow() ## [1] 23 What is the most common word in the book? words %&gt;% count(word) %&gt;% top_n(1, n) %&gt;% pull(word) ## [1] &quot;elizabeth&quot; How many times does that most common word appear? words %&gt;% count(word) %&gt;% top_n(1, n) %&gt;% pull(n) ## [1] 597 Define the afinn lexicon. afinn &lt;- get_sentiments(&quot;afinn&quot;) Note that this command will trigger a question in the R Console asking if you want to download the AFINN lexicon. Press 1 to select “Yes” (if using RStudio, enter this in the Console tab). Use this afinn lexicon to assign sentiment values to words. Keep only words that are present in both words and the afinn lexicon. Save this data frame as afinn_sentiments. How many elements of words have sentiments in the afinn lexicon? afinn_sentiments &lt;- inner_join(afinn, words) ## Joining, by = &quot;word&quot; nrow(afinn_sentiments) ## [1] 6065 What proportion of words in afinn_sentiments have a positive value? mean(afinn_sentiments$value &gt; 0) ## [1] 0.563 How many elements of afinn_sentiments have a value of 4? sum(afinn_sentiments$value == 4) ## [1] 51 5.5 Final: Comprehensive Assessment 5.5.1 Comprehensive Assessment: Puerto Rico Hurricane Mortality 5.5.2 Project Introduction On September 20, 2017, Hurricane Maria made landfall on Puerto Rico. It was the worst natural disaster on record in Puerto Rico and the deadliest Atlantic hurricane since 2004. However, Puerto Rico’s official death statistics only tallied 64 deaths caused directly by the hurricane (due to structural collapse, debris, floods and drownings), an undercount that slowed disaster recovery funding. The majority of the deaths resulted from infrastructure damage that made it difficult to access resources like clean food, water, power, healthcare and communications in the months after the disaster, and although these deaths were due to effects of the hurricane, they were not initially counted. In order to correct the misconception that few lives were lost in Hurricane Maria, statisticians analyzed how death rates in Puerto Rico changed after the hurricane and estimated the excess number of deaths likely caused by the storm. This analysis suggested that the actual number of deaths in Puerto Rico was 2,975 (95% CI: 2,658-3,290) over the 4 months following the hurricane, much higher than the original count. We will use your new data wrangling skills to extract actual daily mortality data from Puerto Rico and investigate whether the Hurricane Maria had an immediate effect on daily mortality compared to unaffected days in September 2015-2017. options(digits = 3) # report 3 significant digits 5.5.3 Puerto Rico Hurricane Mortality - Part 1 In the extdata directory of the dslabs package, you will find a PDF file containing daily mortality data for Puerto Rico from Jan 1, 2015 to May 31, 2018. You can find the file like this: fn &lt;- system.file(&quot;extdata&quot;, &quot;RD-Mortality-Report_2015-18-180531.pdf&quot;, package=&quot;dslabs&quot;) Find and open the file or open it directly from RStudio. On a Mac, you can type: system2(&quot;open&quot;, args = fn) and on Windows, you can type: system(&quot;cmd.exe&quot;, input = paste(&quot;start&quot;, fn)) Which of the following best describes this file? A. It is a table. Extracting the data will be easy. B. It is a report written in prose. Extracting the data will be impossible. C. It is a report combining graphs and tables. Extracting the data seems possible. D. It shows graphs of the data. Extracting the data will be difficult. We are going to create a tidy dataset with each row representing one observation. The variables in this dataset will be year, month, day and deaths. Use the pdftools package to read in fn using the pdf_text function. Store the results in an object called txt. txt &lt;- pdf_text(fn) class(txt) ## [1] &quot;character&quot; str(txt) ## chr [1:12] &quot;6/4/2018 Departamento de Salud - Registro Demográfico - División de Calidad y Estadística&quot;| __truncated__ ... length(txt) ## [1] 12 Describe what you see in txt. A. A table with the mortality data. B. A character string of length 12. Each entry represents the text in each page. The mortality data is in there somewhere. C. A character string with one entry containing all the information in the PDF file. D. An html document. Extract the ninth page of the PDF file from the object txt, then use the str_split function from the stringr package so that you have each line in a different entry. The new line character is \\n. Call this string vector x. Look at x. What best describes what you see? What kind of object is x? How many entries does x have? x &lt;- str_split(txt[9], &quot;\\n&quot;) class(x) ## [1] &quot;list&quot; length(x) ## [1] 1 A. It is an empty string. B. I can see the figure shown in page 1. C. It is a tidy table. D. I can see the table! But there is a bunch of other stuff we need to get rid of. Define s to be the first entry of the x object. What kind of object is s? How many entries does s have? s &lt;- x[[1]] class(s) ## [1] &quot;character&quot; length(s) ## [1] 40 When inspecting the string we obtained above, we see a common problem: white space before and after the other characters. Trimming is a common first step in string processing. These extra spaces will eventually make splitting the strings hard so we start by removing them. We learned about the command str_trimthat removes spaces at the start or end of the strings. Use this function to trim s and assign the result to s again. After trimming, what single character is the last character of element 1 of s? s &lt;- str_trim(s) s[1] # print string, visually inspect last character ## [1] &quot;6/4/2018 Departamento de Salud - Registro Demográfico - División de Calidad y Estadísticas Vitales&quot; We want to extract the numbers from the strings stored in s. However, there are a lot of non-numeric characters that will get in the way. We can remove these, but before doing this we want to preserve the string with the column header, which includes the month abbreviation. Use the str_which function to find the row with the header. Save this result to header_index. Hint: find the first string that matches the pattern \"2015\" using the str_which function. What is the value of header_index? header_index &lt;- str_which(s, pattern=&quot;2015&quot;)[1] header_index ## [1] 2 We want to extract two objects from the header row: month will store the month and header will store the column names. Save the content of the header row into an object called header, then use str_split to help define the two objects we need. What is the value of month? Use header_index to extract the row. The separator here is one or more spaces. Also, consider using the simplify argument. What is the third value in header? tmp &lt;- str_split(s[header_index], pattern=&quot;\\\\s+&quot;, simplify=TRUE) month &lt;- tmp[1] header &lt;- tmp[-1] month ## [1] &quot;SEP&quot; header[3] ## [1] &quot;2017&quot; 5.5.4 Puerto Rico Hurricane Mortality - Part 2 Notice that towards the end of the page defined by s you see a “Total” row followed by rows with other summary statistics. Create an object called tail_index with the index of the “Total” entry. What is the value of tail_index? tail_index &lt;- str_which(s, &quot;Total&quot;) tail_index ## [1] 35 Because our PDF page includes graphs with numbers, some of our rows have just one number (from the y-axis of the plot). Use the str_count function to create an object n with the count of numbers in each row. How many rows have a single number in them? You can write a regex for a number like this \\\\d+. n &lt;- str_count(s, &quot;\\\\d+&quot;) sum(n == 1) ## [1] 2 We are now ready to remove entries from rows that we know we don’t need. The entry header_index and everything before it should be removed. Entries for which n is 1 should also be removed, and the entry tail_index and everything that comes after it should be removed as well. How many entries remain in s? out &lt;- c(1:header_index, which(n==1), tail_index:length(s)) s &lt;- s[-out] length(s) ## [1] 30 Now we are ready to remove all text that is not a digit or space. Do this using regular expressions (regex) and the str_remove_all function. In regex, using the ^ inside the square brackets [] means not, like the ! means not in !=. To define the regex pattern to catch all non-numbers, you can type [^\\\\d]. But remember you also want to keep spaces. Which of these commands produces the correct output? A. s &lt;- str_remove_all(s, &quot;[^\\\\d]&quot;) B. s &lt;- str_remove_all(s, &quot;[\\\\d\\\\s]&quot;) C. s &lt;- str_remove_all(s, &quot;[^\\\\d\\\\s]&quot;) D. s &lt;- str_remove_all(s, &quot;[\\\\d]&quot;) Use the str_split_fixed function to convert s into a data matrix with just the day and death count data: s &lt;- str_split_fixed(s, &quot;\\\\s+&quot;, n = 6)[,1:5] Now you are almost ready to finish. Add column names to the matrix: the first column should be day and the next columns should be the header. Convert all values to numeric. Also, add a column with the month. Call the resulting object tab. What was the mean number of deaths per day in September 2015? tab &lt;- s %&gt;% as_data_frame() %&gt;% setNames(c(&quot;day&quot;, header)) %&gt;% mutate_all(as.numeric) mean(tab$&quot;2015&quot;) ## [1] 75.3 What is the mean number of deaths per day in September 2016? mean(tab$`2016`) ## [1] 78.9 Hurricane Maria hit Puerto Rico on September 20, 2017. What was the mean number of deaths per day from September 1-19, 2017, before the hurricane hit? mean(tab$`2017`[1:19]) ## [1] 83.7 What was the mean number of deaths per day from September 20-30, 2017, after the hurricane hit? mean(tab$`2017`[20:30]) ## [1] 122 Finish it up by changing tab to a tidy format, starting from this code outline: tab &lt;- tab %&gt;% ________(year, deaths, -day) %&gt;% mutate(deaths = as.numeric(deaths)) tab What code fills the blank to generate a data frame with columns named “day”, “year” and “deaths”? tab &lt;- tab %&gt;% gather(year, deaths, -day) %&gt;% mutate(deaths = as.numeric(deaths)) tab ## # A tibble: 120 x 3 ## day year deaths ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2015 75 ## 2 2 2015 77 ## 3 3 2015 67 ## 4 4 2015 71 ## 5 5 2015 62 ## 6 6 2015 77 ## 7 7 2015 85 ## 8 8 2015 84 ## 9 9 2015 79 ## 10 10 2015 66 ## # … with 110 more rows A. separate B. unite C. gather D. spread Make a plot of deaths versus day with color to denote year. Exclude 2018 since we have no data. Add a vertical line at day 20, the day that Hurricane Maria hit in 2017. tab %&gt;% filter(year &lt; 2018) %&gt;% ggplot(aes(day, deaths, color = year)) + geom_line() + geom_vline(xintercept = 20) + geom_point() Which of the following are TRUE? A. September 2015 and 2016 deaths by day are roughly equal to each other. B. The day with the most deaths was the day of the hurricane: September 20, 2017. C. After the hurricane in September 2017, there were over 100 deaths per day every day for the rest of the month. D. No days before September 20, 2017 have over 100 deaths per day. "]
]
